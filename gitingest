(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
<div align="center">
  <h1>ğŸš€ Mercurio Systems Trading Platform</h1>
  <p><strong>The intelligent, resilient algorithmic trading platform that adapts to any market condition</strong></p>
  <p>
    <a href="#installation"><img src="https://img.shields.io/badge/Installation-Guide-blue"/></a>
    <a href="#quick-start"><img src="https://img.shields.io/badge/Quick-Start-brightgreen"/></a>
    <a href="docs/for-dummies/01-introduction.md"><img src="https://img.shields.io/badge/Documentation-Complete-orange"/></a>
    <a href="https://mercurio.systems"><img src="https://img.shields.io/badge/Website-https%3A%2F%2Fmercurio.systems-blue"/></a>
    <a href="https://github.com/deepload/Mercurio"><img src="https://img.shields.io/badge/GitHub-https%3A%2F%2Fgithub.com%2Fdeepload%2FMercurio-blue"/></a>
    <a href="LICENSE"><img src="https://img.shields.io/badge/License-MIT-yellow"/></a>
  </p>
</div>

## ğŸ’¼ Overview

Mercurio is a comprehensive algorithmic trading platform built with reliability and versatility at its core. Whether you're a beginner exploring trading strategies or an expert deploying sophisticated machine learning models, Mercurio provides all the tools you need in one integrated ecosystem.

### ğŸŒŸ Key Features

- **Multiple Strategy Types**: From simple moving averages to advanced ML models (LSTM, Transformer, LLM)
- **Fallback Mechanisms**: Test and trade without API keys using our multi-layered fallback system
- **Paper Trading Mode**: Practice risk-free with simulated trading
- **Comprehensive Backtesting**: Evaluate strategies against historical data
- **Interactive Dashboards**: Monitor performance with Streamlit-powered visualizations
- **Asset Diversity**: Trade stocks and cryptocurrencies (BTC-USD, ETH-USD, etc.) across multiple timeframes
- **Resilient Architecture**: Ensures continuous operation even during outages

## ğŸ“‚ Project Structure

<details>
<summary><strong>Click to expand project structure</strong></summary>

```
Mercurio/
â”œâ”€â”€ app/                       # Core application directory
â”‚   â”œâ”€â”€ main.py                # FastAPI application entry point
â”‚   â”œâ”€â”€ api/                   # API endpoints
â”‚   â”‚   â”œâ”€â”€ routes.py          # API route definitions
â”‚   â”‚   â””â”€â”€ schemas.py         # Pydantic models for requests/responses
â”‚   â”œâ”€â”€ services/              # Business logic services
â”‚   â”‚   â”œâ”€â”€ market_data.py     # Service for fetching market data
â”‚   â”‚   â”œâ”€â”€ trading.py         # Service for executing trades
â”‚   â”‚   â””â”€â”€ backtesting.py     # Service for backtesting strategies
â”‚   â”œâ”€â”€ strategies/            # Trading strategies
â”‚   â”‚   â”œâ”€â”€ base.py            # Base strategy class
â”‚   â”‚   â”œâ”€â”€ moving_average.py  # Moving Average Crossover strategy
â”‚   â”‚   â”œâ”€â”€ lstm_predictor.py  # LSTM-based prediction strategy
â”‚   â”‚   â”œâ”€â”€ transformer.py     # Transformer-based strategy
â”‚   â”‚   â”œâ”€â”€ llm_strategy.py    # LLM-powered strategy
â”‚   â”‚   â””â”€â”€ msi_strategy.py    # Market Sentiment Index strategy
â”‚   â”œâ”€â”€ db/                    # Database modules
â”‚   â”‚   â”œâ”€â”€ database.py        # Database connection
â”‚   â”‚   â””â”€â”€ models.py          # SQLAlchemy models
â”‚   â”œâ”€â”€ tasks/                 # Celery tasks
â”‚   â”‚   â”œâ”€â”€ celery_app.py      # Celery configuration
â”‚   â”‚   â”œâ”€â”€ training.py        # Tasks for model training
â”‚   â”‚   â”œâ”€â”€ trading.py         # Tasks for automated trading
â”‚   â”‚   â””â”€â”€ data.py            # Tasks for data collection
â”‚   â””â”€â”€ utils/                 # Utility functions
â”œâ”€â”€ docs/                      # Documentation directory
â”‚   â”œâ”€â”€ for-dummies/           # Comprehensive guide for beginners
â”‚   â”œâ”€â”€ guides/                # Specialized guides
â”‚   â”‚   â”œâ”€â”€ beginner/          # Beginner guides
â”‚   â”‚   â””â”€â”€ advanced/          # Advanced guides
â”‚   â”œâ”€â”€ api/                   # API documentation
â”‚   â”œâ”€â”€ reference/             # Technical reference
â”‚   â””â”€â”€ README.md              # Documentation index
â”œâ”€â”€ models/                    # Saved ML models
â”‚   â”œâ”€â”€ lstm/                  # LSTM models and scalers
â”‚   â””â”€â”€ transformer/           # Transformer models and scalers
â”œâ”€â”€ data/                      # Data directory
â”‚   â””â”€â”€ sample_data/           # Sample data for testing
â”œâ”€â”€ reports/                   # Reports and visualizations
â”‚   â”œâ”€â”€ comprehensive/         # Comprehensive simulation results
â”‚   â””â”€â”€ visualizations/        # Generated charts and graphs
â”œâ”€â”€ tests/                     # Tests directory
â”œâ”€â”€ comprehensive_simulation.py # Full-featured simulation script
â”œâ”€â”€ strategy_dashboard.py      # Streamlit dashboard for strategy visualization
â”œâ”€â”€ docker-compose.yml         # Docker Compose configuration
â”œâ”€â”€ Dockerfile                 # Docker configuration
â”œâ”€â”€ requirements.txt           # Python dependencies
â”œâ”€â”€ .env.example              # Example environment variables
â””â”€â”€ README.md                 # This file (you are here)
```
</details>

## ğŸš€ Getting Started

### Prerequisites

<table>
  <tr>
    <td><strong>Required</strong></td>
    <td>
      â€¢ Python 3.11 or later<br>
      â€¢ Git
    </td>
  </tr>
  <tr>
    <td><strong>Optional</strong></td>
    <td>
      â€¢ Docker and Docker Compose (for containerized deployment)<br>
      â€¢ Polygon.io API key (for production-quality market data)<br>
      â€¢ Alpaca Paper Trading API keys (for risk-free paper trading)<br>
      â€¢ Alpaca Live Trading API keys (for real money trading)<br>
    </td>
  </tr>
  <tr>
    <td><strong>Note</strong></td>
    <td>Thanks to Mercurio's fallback system, no API keys are required to get started with testing and development!</td>
  </tr>
</table>

### ğŸ’» Installation

<details open>
<summary><strong>Standard Installation</strong></summary>

```bash
# Clone the repository
git clone https://github.com/deepload/Mercurio
cd mercurio-systems

# Create and activate virtual environment
python -m venv venv
venv\Scripts\activate  # On Windows
# source venv/bin/activate  # On Unix/MacOS

# Install dependencies
pip install -r requirements.txt

# Set up environment variables (optional for testing)
copy .env.example .env
# Edit .env with your API keys if available
# For Alpaca, configure both paper and live trading modes:
```
</details>

<details>
<summary><strong>Docker Installation</strong></summary>

```bash
# Clone the repository
git clone https://github.com/deepload/Mercurio
cd mercurio-systems

# Create environment file
copy .env.example .env
# Edit .env with your configuration

# Start the services
docker-compose up -d
```

The following services will be available:
- API: http://localhost:8000
- Swagger UI: http://localhost:8000/docs
- Flower (Celery monitoring): http://localhost:5555
</details>

## ğŸƒâ€â™‚ï¸ Quick Start

### 1. Run a Simple Strategy

```python
# simple_strategy.py
from app.services.market_data import MarketDataService
from app.strategies.moving_average import MovingAverageStrategy
import asyncio

async def run_simple_strategy():
    # Initialize services with fallback enabled
    market_data = MarketDataService(use_fallback=True)
    strategy = MovingAverageStrategy(short_window=10, long_window=30)
    
    # Get historical data (falls back to sample data if needed)
    data = await market_data.get_historical_data("AAPL", "2024-01-01", "2024-03-01")
    
    # Process data and generate signals
    processed_data = await strategy.preprocess_data(data)
    signal, confidence = await strategy.predict(processed_data)
    
    print(f"AAPL Trading Signal: {signal} (Confidence: {confidence:.2f})")

if __name__ == "__main__":
    asyncio.run(run_simple_strategy())
```

Run the script:
```bash
python simple_strategy.py
```

### 2. Launch the Interactive Dashboard

```bash
streamlit run strategy_dashboard.py
```

This will open a browser window with an interactive dashboard to explore strategy performance.

### 3. Run a Comprehensive Simulation

```bash
python comprehensive_simulation.py --timeframe daily
```

## ğŸ”Œ API Reference

<details>
<summary><strong>Available API Endpoints</strong></summary>

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/strategies` | GET | List all available trading strategies |
| `/api/strategies/{strategy_name}` | GET | Get details about a specific strategy |
| `/api/predictions/{strategy_name}/{symbol}` | POST | Get a prediction for a symbol |
| `/api/backtests` | POST | Run a backtest for a strategy |
| `/api/backtests/{backtest_id}` | GET | Get backtest results |
| `/api/models/train` | POST | Train a strategy model |
| `/api/models/{model_id}` | GET | Get model details |
| `/api/trades` | POST | Execute a trade |
| `/api/account` | GET | Get account information |
| `/api/market/status` | GET | Check market status |

For complete API documentation, run the server and visit `/docs` or check the [API Reference](./docs/api/README.md).
</details>

## ğŸ”§ Extending Mercurio Systems

### Creating Custom Strategies

<details>
<summary><strong>Click to see how to add custom strategies</strong></summary>

Mercurio Systems follows a plugin architecture for strategies, making it easy to implement your own trading logic:

1. Create a new Python file in the `app/strategies` directory
2. Extend the `BaseStrategy` class
3. Implement required methods

```python
from app.strategies.base import BaseStrategy
import pandas as pd
import numpy as np

class MyCustomStrategy(BaseStrategy):
    """My custom mean-reversion trading strategy"""
    
    def __init__(self, lookback_period=20, threshold=2.0):
        self.lookback_period = lookback_period
        self.threshold = threshold
        self.name = "MeanReversionStrategy"
        self.description = "Buys oversold assets and sells overbought assets"
        
    async def preprocess_data(self, data):
        """Calculate z-scores for mean reversion"""
        df = data.copy()
        
        # Calculate rolling mean and standard deviation
        df['rolling_mean'] = df['close'].rolling(window=self.lookback_period).mean()
        df['rolling_std'] = df['close'].rolling(window=self.lookback_period).std()
        
        # Calculate z-score
        df['z_score'] = (df['close'] - df['rolling_mean']) / df['rolling_std']
        
        return df.dropna()
        
    async def predict(self, data):
        """Generate trading signals based on z-scores"""
        if data.empty or len(data) < self.lookback_period:
            return "HOLD", 0.0
            
        current_z = data.iloc[-1]['z_score']
        
        # Mean reversion logic
        if current_z < -self.threshold:
            # Oversold, potential buy
            signal = "BUY"
            confidence = min(abs(current_z) / 4, 1.0)  # Normalize confidence
        elif current_z > self.threshold:
            # Overbought, potential sell
            signal = "SELL"
            confidence = min(abs(current_z) / 4, 1.0)  # Normalize confidence
        else:
            signal = "HOLD"
            confidence = 1.0 - (abs(current_z) / self.threshold)
            
        return signal, float(confidence)
```

Register your strategy in `app/strategies/__init__.py` to make it available throughout the system.
</details>

### Custom Data Sources

<details>
<summary><strong>Click to see how to add custom data sources</strong></summary>

Extend the `BaseDataProvider` class to integrate with any market data source:

```python
from app.services.data_providers.base import BaseDataProvider
import pandas as pd
import requests

class MyCustomDataProvider(BaseDataProvider):
    """Custom data provider for XYZ market data"""
    
    def __init__(self, api_key=None):
        self.api_key = api_key
        self.base_url = "https://api.example.com/v1"
        
    async def get_historical_data(self, symbol, start_date, end_date, timeframe="1d"):
        """Fetch historical market data from custom source"""
        # Implementation
        headers = {"Authorization": f"Bearer {self.api_key}"} if self.api_key else {}
        params = {
            "symbol": symbol,
            "from": start_date,
            "to": end_date,
            "interval": timeframe
        }
        
        response = requests.get(f"{self.base_url}/historical", headers=headers, params=params)
        data = response.json()
        
        # Transform to standard format
        df = pd.DataFrame(data["bars"])
        df.columns = ["timestamp", "open", "high", "low", "close", "volume"]
        df["timestamp"] = pd.to_datetime(df["timestamp"])
        df.set_index("timestamp", inplace=True)
        
        return df
```
</details>

## ğŸ”¬ Running the Comprehensive Simulation

Test all available strategies across different assets and timeframes:

```bash
python comprehensive_simulation.py --start-date 2024-03-03 --end-date 2025-04-25 --initial-capital 10000
```

This runs a full-year simulation using:
- **5 Stock Assets**: AAPL, MSFT, GOOGL, AMZN, TSLA
- **5 Crypto Assets**: BTC-USD, ETH-USD, SOL-USD, ADA-USD, DOT-USD
- **All Strategies**: MovingAverage, LSTM, Transformer, LLM, MSI
- **Multiple Timeframes**: Daily, Weekly, Monthly

Results are saved to the `reports/comprehensive/` directory with full metrics and visualizations.

## ğŸ“š Documentation

Comprehensive documentation is available in the [docs](./docs) directory:

### ğŸ“” Guides Principaux

- **[ğŸ” Index des Guides](./docs/GUIDES_INDEX.md)**: Point d'entrÃ©e central avec tous les guides disponibles
- **[ğŸ“ˆ Guide de Day Trading](./docs/day_trading_guide.md)**: SystÃ¨me automatisÃ© de day trading sur actions et crypto
- **[ğŸ“Š Guide des Options](./docs/options_trading.md)**: Trading d'options avec Mercurio AI
- **[ğŸ§  Guide d'EntraÃ®nement des ModÃ¨les](./docs/model_training_guide.md)**: CrÃ©er et entraÃ®ner des modÃ¨les d'IA

### ğŸ“– Documentation GÃ©nÃ©rale

- **[ğŸ“š Pour les DÃ©butants](./docs/for-dummies/README.md)**: Guide complet en 12 chapitres pour dÃ©butants
- **[ğŸ”° Guides DÃ©butants](./docs/guides/beginner/)**: Ressources pour dÃ©marrer rapidement
- **[ğŸ”§ Guides AvancÃ©s](./docs/guides/advanced/)**: Sujets spÃ©cialisÃ©s pour traders expÃ©rimentÃ©s
- **[ğŸ“ Documentation RÃ©fÃ©rence](./docs/reference/)**: DÃ©tails techniques et spÃ©cifications API

## ğŸ§ª Testing

```bash
# Run the test suite
pytest

# Run tests with coverage
pytest --cov=app
```

## ğŸ¤ Contributing

Contributions are welcome! Check out the [contribution guidelines](CONTRIBUTING.md) to get started.

## ğŸ“„ License

This project is open-source and available under the MIT License.

## ğŸŒŸ Showcase

<div align="center">
  <table>
    <tr>
      <td align="center"><img src="https://i.imgur.com/2sGSK1h.png" width="400"/><br><b>Strategy Comparison</b></td>
      <td align="center"><img src="https://i.imgur.com/7fVLnMF.png" width="400"/><br><b>Portfolio Allocation</b></td>
    </tr>
  </table>
</div>

## ğŸ™ Acknowledgements

- [FastAPI](https://fastapi.tiangolo.com/)
- [SQLAlchemy](https://www.sqlalchemy.org/)
- [PyTorch](https://pytorch.org/)
- [Pandas](https://pandas.pydata.org/)
- [Streamlit](https://streamlit.io/)
- [Polygon.io](https://polygon.io/)
- [Yahoo Finance](https://finance.yahoo.com/)
- [Alpaca Markets](https://alpaca.markets/)
- [Backtrader](https://www.backtrader.com/)



================================================
FILE: alpaca_crypto_trader.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca Crypto Day Trading Script
--------------------------------
Script autonome pour le daytrading de cryptomonnaies via Alpaca API,
optimisÃ© pour l'abonnement de niveau 3 (AlgoTrader Plus).

Utilisation:
    python alpaca_crypto_trader.py --duration 1h --log-level INFO
"""

import os
import time
import signal
import logging
import argparse
import asyncio
from enum import Enum
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta

# API Alpaca
import alpaca_trade_api as tradeapi
import pandas as pd
from dotenv import load_dotenv

# Chargement des variables d'environnement
load_dotenv()

# Configuration du logger
# Configurer la journalisation pour enregistrer dans un fichier
log_file = f"crypto_trader_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("alpaca_crypto_trader")

# Variables globales pour la gestion des signaux
running = True
session_end_time = None

# Enums pour la durÃ©e de session
class SessionDuration(int, Enum):
    ONE_HOUR = 3600
    FOUR_HOURS = 14400
    EIGHT_HOURS = 28800
    NIGHT_RUN = 32400  # 9 heures (pour couvrir toute la nuit)
    CUSTOM = 0

class AlpacaCryptoTrader:
    """
    SystÃ¨me de daytrading crypto utilisant directement l'API Alpaca
    
    CaractÃ©ristiques:
    - Utilise l'API Alpaca pour trader des cryptos en mode paper
    - StratÃ©gie simple de croisement de moyennes mobiles
    - Plusieurs durÃ©es de session (1h, 4h, 8h, nuit)
    - ParamÃ¨tres de trading configurables
    - Journalisation complÃ¨te et rapport de performance
    """
    
    def __init__(self, session_duration: SessionDuration = SessionDuration.ONE_HOUR):
        """Initialiser le systÃ¨me de trading crypto"""
        self.session_duration = session_duration
        
        # DÃ©terminer le mode Alpaca (paper ou live)
        alpaca_mode = os.getenv("ALPACA_MODE", "paper").lower()
        
        # Configuration selon le mode
        if alpaca_mode == "live":
            self.api_key = os.getenv("ALPACA_LIVE_KEY")
            self.api_secret = os.getenv("ALPACA_LIVE_SECRET")
            self.base_url = os.getenv("ALPACA_LIVE_URL", "https://api.alpaca.markets")
            logger.info("ConfigurÃ© pour le trading LIVE (rÃ©el)")
        else:  # mode paper par dÃ©faut
            self.api_key = os.getenv("ALPACA_PAPER_KEY")
            self.api_secret = os.getenv("ALPACA_PAPER_SECRET")
            self.base_url = os.getenv("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
            logger.info("ConfigurÃ© pour le trading PAPER (simulation)")
            
        # URL des donnÃ©es de marchÃ©
        self.data_url = os.getenv("ALPACA_DATA_URL", "https://data.alpaca.markets")
        
        # Niveau d'abonnement Alpaca
        self.subscription_level = int(os.getenv("ALPACA_SUBSCRIPTION_LEVEL", "1"))
        logger.info(f"Utilisation du niveau d'abonnement Alpaca: {self.subscription_level}")
        
        # Client API Alpaca
        self.api = None
        
        # ParamÃ¨tres de trading
        self.symbols = []  # Sera rempli avec les symboles crypto disponibles
        self.custom_symbols = []  # Liste personnalisÃ©e de symboles Ã  utiliser
        self.use_custom_symbols = False  # Si True, utilise custom_symbols au lieu de la liste filtrÃ©e
        self.fast_ma_period = 5   # 5 minutes pour la moyenne mobile rapide
        self.slow_ma_period = 15  # 15 minutes pour la moyenne mobile lente
        self.position_size_pct = 0.02  # 2% du portefeuille par position
        self.stop_loss_pct = 0.03  # 3% de stop loss
        self.take_profit_pct = 0.06  # 6% de prise de profit
        
        # Suivi de l'Ã©tat
        self.positions = {}
        self.portfolio_value = 0.0
        self.initial_portfolio_value = 0.0
        self.session_start_time = None
        self.session_end_time = None
        self.trade_history = []  # Pour enregistrer l'historique des transactions
        
        logger.info("AlpacaCryptoTrader initialisÃ©")
        
    def initialize(self):
        """Initialiser les services et charger la configuration"""
        try:
            # Initialiser le client API Alpaca
            self.api = tradeapi.REST(
                key_id=self.api_key,
                secret_key=self.api_secret,
                base_url=self.base_url,
                api_version='v2'
            )
            
            # VÃ©rifier que le client est correctement initialisÃ©
            account = self.api.get_account()
            if account:
                self.portfolio_value = float(account.portfolio_value)
                self.initial_portfolio_value = self.portfolio_value
                logger.info(f"Compte Alpaca connectÃ©: {account.id}")
                logger.info(f"Valeur initiale du portefeuille: ${self.portfolio_value:.2f}")
                logger.info(f"Mode trading: {account.status}")
                
                # VÃ©rifier la disponibilitÃ© du trading crypto
                assets = self.api.list_assets(asset_class='crypto')
                
                if not self.use_custom_symbols:
                    # Filtrer pour ne garder que les paires USD pures (exclure explicitement USDT/USDC)
                    self.symbols = [asset.symbol for asset in assets if asset.tradable 
                                  and '/USD' in asset.symbol 
                                  and not '/USDT' in asset.symbol 
                                  and not '/USDC' in asset.symbol]
                    
                    if self.symbols:
                        logger.info(f"TrouvÃ© {len(self.symbols)} symboles crypto disponibles (USD seulement)")
                        logger.info(f"Exemples: {', '.join(self.symbols[:5])}")
                    else:
                        logger.warning("Aucun symbole crypto disponible avec USD")
                else:
                    # Utiliser la liste personnalisÃ©e et vÃ©rifier que les symboles sont tradables
                    tradable_assets = [asset.symbol for asset in assets if asset.tradable]
                    self.symbols = [symbol for symbol in self.custom_symbols if symbol in tradable_assets]
                    logger.info(f"Utilisation d'une liste personnalisÃ©e de {len(self.symbols)} symboles crypto")
                    if self.symbols:
                        logger.info(f"Exemples: {', '.join(self.symbols[:5])}")
                    else:
                        logger.warning("Aucun symbole personnalisÃ© n'est tradable")
                    
                # VÃ©rifier le solde disponible en USD
                try:
                    account = self.api.get_account()
                    cash = float(account.cash)
                    logger.info(f"Solde USD disponible: ${cash:.2f}")
                except Exception as e:
                    logger.warning(f"Impossible de rÃ©cupÃ©rer le solde USD: {e}")
                    pass
                
                return True
            else:
                logger.error("Impossible de rÃ©cupÃ©rer les informations du compte")
                return False
                
        except Exception as e:
            logger.error(f"Erreur d'initialisation: {e}")
            return False
            
    def start(self, duration_seconds: Optional[int] = None):
        """DÃ©marrer la session de trading crypto"""
        self.session_start_time = datetime.now()
        
        if duration_seconds is not None:
            self.session_end_time = self.session_start_time + timedelta(seconds=duration_seconds)
        else:
            self.session_end_time = self.session_start_time + timedelta(seconds=int(self.session_duration))
            
        logger.info(f"DÃ©marrage de la session de trading crypto Ã  {self.session_start_time}")
        logger.info(f"La session se terminera Ã  {self.session_end_time}")
        
        # Initialiser le trader
        initialized = self.initialize()
        if not initialized:
            logger.error("Ã‰chec de l'initialisation, abandon")
            self.generate_performance_report()
            return
            
        # DÃ©marrer la boucle de trading
        self.trading_loop()
        
        # GÃ©nÃ©rer un rapport de performance Ã  la fin
        self.generate_performance_report()
            
    def trading_loop(self):
        """Boucle principale de trading"""
        global running
        
        try:
            while running and datetime.now() < self.session_end_time:
                # DÃ©terminer les symboles Ã  trader pour cette itÃ©ration
                # Limiter aux 10 premiÃ¨res cryptos pour Ã©viter les limites de taux si pas de liste personnalisÃ©e
                trading_symbols = self.symbols[:10] if (len(self.symbols) > 10 and not self.use_custom_symbols) else self.symbols
                
                # Traiter chaque symbole
                for symbol in trading_symbols:
                    try:
                        self.process_symbol(symbol)
                    except Exception as e:
                        logger.error(f"Erreur de traitement de {symbol}: {e}")
                
                # Mettre Ã  jour l'Ã©tat du portefeuille
                self.update_portfolio_state()
                
                # Attendre 60 secondes avant la prochaine itÃ©ration
                time_remaining = int((self.session_end_time - datetime.now()).total_seconds() / 60)
                logger.info(f"Attente de 60 secondes avant le prochain cycle. Fin de session dans {time_remaining} minutes")
                time.sleep(60)
                
        except Exception as e:
            logger.error(f"Erreur dans la boucle de trading: {e}")
        finally:
            logger.info("Boucle de trading terminÃ©e")
            
    def process_symbol(self, symbol: str):
        """Traiter un symbole de trading"""
        logger.info(f"Traitement de {symbol}")
        
        # Obtenir les donnÃ©es historiques (intervalles de 5 minutes pour les derniÃ¨res 24 heures)
        end = datetime.now()
        start = end - timedelta(days=1)
        
        try:
            # Formater les dates pour l'API
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            # Obtenir les barres de prix (corriger l'erreur expected list, str found)
            bars = self.api.get_crypto_bars(
                [symbol],  # Passer une liste au lieu d'une chaÃ®ne
                timeframe='5Min',
                start=start_str,
                end=end_str
            ).df
            
            if bars.empty:
                logger.warning(f"Pas de donnÃ©es historiques disponibles pour {symbol}")
                return
            
            # Si les donnÃ©es sont multi-index (symbole, timestamp), prendre juste le symbole concernÃ©
            if isinstance(bars.index, pd.MultiIndex):
                bars = bars.loc[symbol]
                
            # Calculer les moyennes mobiles
            bars['fast_ma'] = bars['close'].rolling(window=self.fast_ma_period).mean()
            bars['slow_ma'] = bars['close'].rolling(window=self.slow_ma_period).mean()
            
            # Obtenir la position actuelle
            position = None
            try:
                position = self.api.get_position(symbol)
            except:
                pass  # Pas de position existante
            
            # Obtenir le prix actuel (compatible avec abonnement niveau 1)
            try:
                # Pour le niveau 1, on peut utiliser la derniÃ¨re barre des derniÃ¨res 5 minutes comme prix actuel
                if not bars.empty:
                    current_price = float(bars.iloc[-1]['close'])
                    logger.info(f"{symbol} prix actuel (derniÃ¨re barre): ${current_price:.4f}")
                else:
                    logger.error(f"Pas de donnÃ©es disponibles pour obtenir le prix actuel de {symbol}")
                    return
            except Exception as e:
                logger.error(f"Impossible d'obtenir le prix actuel pour {symbol}: {e}")
                return
            
            # Logique de trading - Croisement de moyennes mobiles
            if len(bars) >= self.slow_ma_period:
                last_row = bars.iloc[-1]
                prev_row = bars.iloc[-2]
                
                # VÃ©rifier le signal d'achat: MA rapide croise au-dessus de la MA lente
                buy_signal = (
                    prev_row['fast_ma'] <= prev_row['slow_ma'] and 
                    last_row['fast_ma'] > last_row['slow_ma']
                )
                
                # VÃ©rifier le signal de vente: MA rapide croise en dessous de la MA lente
                sell_signal = (
                    prev_row['fast_ma'] >= prev_row['slow_ma'] and 
                    last_row['fast_ma'] < last_row['slow_ma']
                )
                
                # ExÃ©cuter les signaux
                if buy_signal and not position:
                    self.execute_buy(symbol, current_price)
                elif sell_signal and position:
                    self.execute_sell(symbol, current_price, position)
                
                # VÃ©rifier le stop loss et le take profit
                if position:
                    entry_price = float(position.avg_entry_price)
                    if entry_price > 0:
                        pnl_pct = (current_price - entry_price) / entry_price
                        
                        if pnl_pct <= -self.stop_loss_pct:
                            logger.info(f"{symbol} a atteint le stop loss Ã  {pnl_pct:.2%}")
                            self.execute_sell(symbol, current_price, position)
                        elif pnl_pct >= self.take_profit_pct:
                            logger.info(f"{symbol} a atteint le take profit Ã  {pnl_pct:.2%}")
                            self.execute_sell(symbol, current_price, position)
            
        except Exception as e:
            logger.error(f"Erreur de traitement de {symbol}: {e}")
    
    def execute_buy(self, symbol: str, price: float):
        """ExÃ©cuter un ordre d'achat"""
        try:
            # Calculer la taille de la position
            position_value = self.portfolio_value * self.position_size_pct
            qty = position_value / price
            
            logger.info(f"SIGNAL D'ACHAT: {symbol} Ã  ${price:.4f}, qtÃ©: {qty:.6f}")
            
            # Arrondir la quantitÃ© Ã  6 dÃ©cimales
            qty = round(qty, 6)
            
            # Placer un ordre au marchÃ©
            order = self.api.submit_order(
                symbol=symbol,
                qty=qty,
                side='buy',
                type='market',
                time_in_force='gtc'
            )
            
            if order:
                logger.info(f"Ordre d'achat placÃ© pour {symbol}: {order.id}")
                self.trade_history.append({
                    'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'symbol': symbol,
                    'action': 'achat',
                    'quantity': qty,
                    'price': price
                })
            else:
                logger.error(f"Ã‰chec du placement de l'ordre d'achat pour {symbol}")
                
        except Exception as e:
            logger.error(f"Erreur d'exÃ©cution d'achat pour {symbol}: {e}")
    
    def execute_sell(self, symbol: str, price: float, position):
        """ExÃ©cuter un ordre de vente"""
        try:
            qty = float(position.qty)
            
            if qty <= 0:
                logger.warning(f"QuantitÃ© de position invalide pour {symbol}: {qty}")
                return
                
            logger.info(f"SIGNAL DE VENTE: {symbol} Ã  ${price:.4f}, qtÃ©: {qty:.6f}")
            
            # Placer un ordre au marchÃ©
            order = self.api.submit_order(
                symbol=symbol,
                qty=qty,
                side='sell',
                type='market',
                time_in_force='gtc'
            )
            
            if order:
                logger.info(f"Ordre de vente placÃ© pour {symbol}: {order.id}")
                self.trade_history.append({
                    'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'symbol': symbol,
                    'action': 'vente',
                    'quantity': qty,
                    'price': price
                })
            else:
                logger.error(f"Ã‰chec du placement de l'ordre de vente pour {symbol}")
                
        except Exception as e:
            logger.error(f"Erreur d'exÃ©cution de vente pour {symbol}: {e}")
    
    def update_portfolio_state(self):
        """Mettre Ã  jour la valeur du portefeuille et les positions"""
        try:
            account = self.api.get_account()
            self.portfolio_value = float(account.portfolio_value)
            logger.info(f"Valeur actuelle du portefeuille: ${self.portfolio_value:.2f}")
            
            # Mettre Ã  jour les positions
            try:
                positions = self.api.list_positions()
                crypto_positions = [p for p in positions if '/' in p.symbol]
                
                # Journaliser les positions ouvertes
                if crypto_positions:
                    logger.info(f"Positions ouvertes actuelles: {len(crypto_positions)}")
                    for pos in crypto_positions:
                        entry_price = float(pos.avg_entry_price)
                        current_price = float(pos.current_price)
                        qty = float(pos.qty)
                        market_value = float(pos.market_value)
                        pnl = float(pos.unrealized_pl)
                        pnl_pct = float(pos.unrealized_plpc) * 100
                        
                        logger.info(f"  {pos.symbol}: {qty:.6f} @ ${entry_price:.4f} - Valeur: ${market_value:.2f} - P/L: ${pnl:.2f} ({pnl_pct:.2f}%)")
                else:
                    logger.info("Pas de positions ouvertes")
            except Exception as e:
                logger.error(f"Erreur de rÃ©cupÃ©ration des positions: {e}")
                
        except Exception as e:
            logger.error(f"Erreur de mise Ã  jour de l'Ã©tat du portefeuille: {e}")
    
    def generate_performance_report(self):
        """GÃ©nÃ©rer un rapport de performance Ã  la fin de la session de trading"""
        # CrÃ©er un fichier de rapport sÃ©parÃ©
        report_file = f"crypto_trading_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        try:
            end_time = datetime.now()
            duration = end_time - self.session_start_time if self.session_start_time else timedelta(0)
            hours, remainder = divmod(duration.seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            
            logger.info("===================================================")
            logger.info("RAPPORT DE PERFORMANCE DE LA SESSION DE TRADING CRYPTO")
            logger.info("===================================================")
            logger.info(f"DurÃ©e de la session: {hours}h {minutes}m {seconds}s")
            logger.info(f"Heure de dÃ©but: {self.session_start_time}")
            logger.info(f"Heure de fin: {end_time}")
            
            # Obtenir l'Ã©tat final du compte
            try:
                account = self.api.get_account()
                final_value = float(account.portfolio_value)
                
                if self.initial_portfolio_value > 0:
                    profit_loss = final_value - self.initial_portfolio_value
                    profit_loss_pct = (profit_loss / self.initial_portfolio_value) * 100
                    logger.info(f"Valeur initiale du portefeuille: ${self.initial_portfolio_value:.2f}")
                    logger.info(f"Valeur finale du portefeuille: ${final_value:.2f}")
                    logger.info(f"Profit/Perte: ${profit_loss:.2f} ({profit_loss_pct:.2f}%)")
            except Exception as e:
                logger.warning(f"Impossible de rÃ©cupÃ©rer les informations finales du compte: {e}")
            
            # Afficher les positions ouvertes
            try:
                positions = self.api.list_positions()
                crypto_positions = [p for p in positions if '/' in p.symbol]
                
                if crypto_positions:
                    logger.info(f"Positions ouvertes Ã  la fin de la session: {len(crypto_positions)}")
                    for pos in crypto_positions:
                        entry_price = float(pos.avg_entry_price)
                        current_price = float(pos.current_price)
                        qty = float(pos.qty)
                        market_value = float(pos.market_value)
                        pnl = float(pos.unrealized_pl)
                        pnl_pct = float(pos.unrealized_plpc) * 100
                        
                        logger.info(f"  {pos.symbol}: {qty:.6f} @ ${entry_price:.4f} - Valeur: ${market_value:.2f} - P/L: ${pnl:.2f} ({pnl_pct:.2f}%)")
                else:
                    logger.info("Pas de positions ouvertes Ã  la fin de la session")
            except Exception as e:
                logger.warning(f"Impossible de rÃ©cupÃ©rer les informations de position: {e}")
                
            logger.info("===================================================")
            logger.info("SESSION DE TRADING CRYPTO TERMINÃ‰E")
            logger.info("===================================================")
                
        except Exception as e:
            logger.error(f"Erreur de gÃ©nÃ©ration du rapport de performance: {e}")

        # Ã‰crire le rapport Ã©galement dans un fichier sÃ©parÃ©
        with open(report_file, 'w') as f:
            f.write("===================================================\n")
            f.write("RAPPORT DE PERFORMANCE DE LA SESSION DE TRADING CRYPTO\n")
            f.write("===================================================\n\n")
            f.write(f"DurÃ©e de la session: {hours}h {minutes}m {seconds}s\n")
            f.write(f"Heure de dÃ©but: {self.session_start_time}\n")
            f.write(f"Heure de fin: {end_time}\n\n")
            
            try:
                if self.initial_portfolio_value > 0:
                    f.write(f"Valeur initiale du portefeuille: ${self.initial_portfolio_value:.2f}\n")
                    f.write(f"Valeur finale du portefeuille: ${final_value:.2f}\n")
                    f.write(f"Profit/Perte: ${profit_loss:.2f} ({profit_loss_pct:.2f}%)\n\n")
            except:
                f.write("Impossible de rÃ©cupÃ©rer les informations finales du compte\n\n")
                
            f.write("Positions ouvertes Ã  la fin de la session:\n")
            try:
                if crypto_positions:
                    for pos in crypto_positions:
                        f.write(f"  {pos.symbol}: {float(pos.qty):.6f} @ ${float(pos.avg_entry_price):.4f} - ")
                        f.write(f"Valeur: ${float(pos.market_value):.2f} - ")
                        f.write(f"P/L: ${float(pos.unrealized_pl):.2f} ({float(pos.unrealized_plpc) * 100:.2f}%)\n")
                else:
                    f.write("Aucune position ouverte\n")
            except:
                f.write("Impossible de rÃ©cupÃ©rer les informations de position\n")
            
            f.write("\n===================================================\n")
            f.write("RÃ‰SUMÃ‰ DES TRANSACTIONS IMPORTANTES\n")
            f.write("===================================================\n")
            if hasattr(self, 'trade_history') and self.trade_history:
                for trade in self.trade_history:
                    f.write(f"{trade['time']} - {trade['symbol']} - {trade['action']} - ")
                    f.write(f"{trade['quantity']:.6f} @ ${trade['price']:.4f} - P/L: ${trade.get('pnl', 0):.2f}\n")
            else:
                f.write("Aucune transaction effectuÃ©e\n")
                
        logger.info(f"Rapport dÃ©taillÃ© sauvegardÃ© dans {report_file}")

def main():
    """Point d'entrÃ©e principal"""
    parser = argparse.ArgumentParser(description="SystÃ¨me de trading crypto Alpaca")
    parser.add_argument("--duration", type=str, choices=["1h", "4h", "8h", "custom"], default="1h",
                        help="DurÃ©e de la session de trading (1h, 4h, 8h, ou custom)")
    parser.add_argument("--custom-seconds", type=int, default=0,
                        help="DurÃ©e personnalisÃ©e en secondes si --duration=custom")
    parser.add_argument("--log-level", type=str, choices=["DEBUG", "INFO", "WARNING", "ERROR"], 
                        default="INFO", help="Niveau de journalisation")
                        
    args = parser.parse_args()
    
    # DÃ©finir le niveau de journalisation
    numeric_level = getattr(logging, args.log_level)
    logging.basicConfig(level=numeric_level, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
    
    # DÃ©terminer la durÃ©e de la session
    duration_map = {
        "1h": SessionDuration.ONE_HOUR,
        "4h": SessionDuration.FOUR_HOURS,
        "8h": SessionDuration.EIGHT_HOURS,
        "custom": SessionDuration.CUSTOM
    }
    session_duration = duration_map.get(args.duration, SessionDuration.ONE_HOUR)
    custom_duration = args.custom_seconds if args.duration == "custom" else 0
    
    # CrÃ©er le trader
    trader = AlpacaCryptoTrader(session_duration=session_duration)
    
    # Enregistrer les gestionnaires de signaux pour une fermeture propre
    def signal_handler(sig, frame):
        global running, session_end_time
        logger.info(f"Signal {sig} reÃ§u, arrÃªt en cours...")
        running = False
        session_end_time = datetime.now()
        
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # ExÃ©cuter le trader
    try:
        if custom_duration > 0:
            trader.start(custom_duration)
        else:
            trader.start()
    except KeyboardInterrupt:
        logger.info("Interruption clavier reÃ§ue, arrÃªt en cours...")
    except Exception as e:
        logger.error(f"Erreur d'exÃ©cution du trader crypto: {e}")
    finally:
        logger.info("ArrÃªt du trader crypto terminÃ©")

if __name__ == "__main__":
    main()



================================================
FILE: alpaca_premium_test.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca Premium Subscription Test

VÃ©rifie spÃ©cifiquement les fonctionnalitÃ©s premium de votre abonnement Alpaca Ã  100$/mois.
"""

import os
import sys
import json
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Configure logging to be plus lisible
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("âœ… alpaca-trade-api importÃ© avec succÃ¨s")
except ImportError:
    logger.error("âŒ Erreur d'importation de alpaca-trade-api. Installation...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("âœ… alpaca-trade-api installÃ© et importÃ© avec succÃ¨s")

def test_premium_features():
    """Teste les fonctionnalitÃ©s spÃ©cifiques aux abonnements premium d'Alpaca"""
    
    # Charger les variables d'environnement
    load_dotenv()
    
    # Tester Ã  la fois le mode PAPER et LIVE si possible
    results = {}
    
    for mode in ["paper", "live"]:
        logger.info(f"\n{'='*60}")
        logger.info(f"TEST DU MODE {mode.upper()}")
        logger.info(f"{'='*60}\n")
        
        # RÃ©cupÃ©rer les informations d'authentification appropriÃ©es
        if mode == "paper":
            api_key = os.environ.get("ALPACA_PAPER_KEY")
            api_secret = os.environ.get("ALPACA_PAPER_SECRET")
            base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
            data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
        else:
            api_key = os.environ.get("ALPACA_LIVE_KEY")
            api_secret = os.environ.get("ALPACA_LIVE_SECRET")
            base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
            data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
        
        results[mode] = {
            "connection": False,
            "account_info": False,
            "market_data": {
                "daily": False,
                "minute": False,
                "realtime": False,
                "extended_history": False,
                "multiple_symbols": False,
            },
            "news_data": False,
            "fundamental_data": False,
            "subscription_tier": "Unknown"
        }
        
        try:
            # Initialiser l'API Alpaca
            api = REST(
                key_id=api_key,
                secret_key=api_secret,
                base_url=base_url,
                data_url=data_url
            )
            results[mode]["connection"] = True
            logger.info(f"âœ… ConnectÃ© Ã  l'API Alpaca en mode {mode.upper()}")
            
            # 1. Test des informations de compte
            try:
                account = api.get_account()
                results[mode]["account_info"] = True
                logger.info(f"âœ… Informations du compte: ID={account.id}, Status={account.status}")
                logger.info(f"   Valeur portefeuille: ${float(account.portfolio_value):.2f}")
                
                # Essayer de dÃ©terminer le niveau d'abonnement
                try:
                    if hasattr(account, 'subscription_status'):
                        results[mode]["subscription_tier"] = account.subscription_status
                        logger.info(f"âœ… Niveau d'abonnement: {account.subscription_status}")
                    else:
                        logger.info("â„¹ï¸ Impossible de dÃ©terminer le niveau d'abonnement directement")
                except:
                    pass
            except Exception as e:
                logger.error(f"âŒ Erreur lors de la rÃ©cupÃ©ration des informations du compte: {e}")
            
            # 2. Test des donnÃ©es de marchÃ© historiques (journaliÃ¨res)
            logger.info("\n----- TEST DES DONNÃ‰ES DE MARCHÃ‰ -----")
            symbol = "AAPL"
            end_date = datetime.now()
            
            # 2.1 Test donnÃ©es journaliÃ¨res sur 5 jours (devrait fonctionner mÃªme sans abonnement premium)
            try:
                start_date = end_date - timedelta(days=5)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"RÃ©cupÃ©ration des donnÃ©es journaliÃ¨res pour {symbol} du {start_str} au {end_str}...")
                daily_bars = api.get_bars(symbol, "1Day", start_str, end_str)
                
                if len(daily_bars) > 0:
                    results[mode]["market_data"]["daily"] = True
                    logger.info(f"âœ… {len(daily_bars)} barres journaliÃ¨res rÃ©cupÃ©rÃ©es")
                    logger.info(f"   Dernier prix de clÃ´ture: ${daily_bars[-1].c:.2f}")
                else:
                    logger.warning(f"âš ï¸ Aucune donnÃ©e journaliÃ¨re rÃ©cupÃ©rÃ©e pour {symbol}")
            except Exception as e:
                logger.error(f"âŒ Erreur lors de la rÃ©cupÃ©ration des donnÃ©es journaliÃ¨res: {e}")
            
            # 2.2 Test donnÃ©es minutes (souvent limitÃ© aux abonnements premium)
            try:
                start_date = end_date - timedelta(days=1)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"RÃ©cupÃ©ration des donnÃ©es minutes pour {symbol} des derniÃ¨res 24h...")
                minute_bars = api.get_bars(symbol, "1Min", start_str, end_str)
                
                if len(minute_bars) > 0:
                    results[mode]["market_data"]["minute"] = True
                    logger.info(f"âœ… {len(minute_bars)} barres minutes rÃ©cupÃ©rÃ©es")
                    logger.info(f"   PremiÃ¨re barre: {minute_bars[0].t}")
                    logger.info(f"   DerniÃ¨re barre: {minute_bars[-1].t}")
                else:
                    logger.warning(f"âš ï¸ Aucune donnÃ©e minute rÃ©cupÃ©rÃ©e pour {symbol}")
            except Exception as e:
                logger.error(f"âŒ Erreur lors de la rÃ©cupÃ©ration des donnÃ©es minutes: {e}")
            
            # 2.3 Test historique Ã©tendu (2+ ans, souvent limitÃ© aux abonnements premium)
            try:
                start_date = end_date - timedelta(days=365*2 + 30)  # ~2 ans et 1 mois
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"RÃ©cupÃ©ration de l'historique Ã©tendu pour {symbol} (2+ ans)...")
                long_bars = api.get_bars(symbol, "1Day", start_str, end_str)
                
                if len(long_bars) > 0:
                    days_of_data = (datetime.fromisoformat(long_bars[-1].t) - 
                                  datetime.fromisoformat(long_bars[0].t)).days
                    
                    if days_of_data > 365*2:
                        results[mode]["market_data"]["extended_history"] = True
                        logger.info(f"âœ… {len(long_bars)} barres d'historique Ã©tendu rÃ©cupÃ©rÃ©es")
                        logger.info(f"   Couvrant {days_of_data} jours de donnÃ©es")
                    else:
                        logger.warning(f"âš ï¸ Historique limitÃ© Ã  {days_of_data} jours (< 2 ans)")
                else:
                    logger.warning(f"âš ï¸ Aucune donnÃ©e d'historique Ã©tendu rÃ©cupÃ©rÃ©e pour {symbol}")
            except Exception as e:
                logger.error(f"âŒ Erreur lors de la rÃ©cupÃ©ration de l'historique Ã©tendu: {e}")
            
            # 2.4 Test donnÃ©es pour plusieurs symboles simultanÃ©ment
            try:
                symbols = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA"]
                logger.info(f"RÃ©cupÃ©ration des donnÃ©es pour plusieurs symboles: {symbols}...")
                
                start_date = end_date - timedelta(days=5)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                multi_bars = api.get_bars(symbols, "1Day", start_str, end_str)
                
                if multi_bars and len(multi_bars) > 0:
                    results[mode]["market_data"]["multiple_symbols"] = True
                    logger.info(f"âœ… DonnÃ©es rÃ©cupÃ©rÃ©es pour plusieurs symboles:")
                    for symbol, bars in multi_bars.items():
                        logger.info(f"   {symbol}: {len(bars)} barres")
                else:
                    logger.warning("âš ï¸ Aucune donnÃ©e rÃ©cupÃ©rÃ©e pour les multiples symboles")
            except Exception as e:
                logger.error(f"âŒ Erreur lors de la rÃ©cupÃ©ration des donnÃ©es multi-symboles: {e}")
            
            # 3. Test des donnÃ©es de news (souvent limitÃ© aux abonnements premium)
            logger.info("\n----- TEST DES DONNÃ‰ES DE NEWS -----")
            try:
                logger.info(f"RÃ©cupÃ©ration des news pour {symbol}...")
                news = api.get_news(symbol)
                
                if news and len(news) > 0:
                    results[mode]["news_data"] = True
                    logger.info(f"âœ… {len(news)} articles de news rÃ©cupÃ©rÃ©s")
                    logger.info(f"   Dernier titre: {news[0].headline}")
                    logger.info(f"   Source: {news[0].source}")
                else:
                    logger.warning(f"âš ï¸ Aucune news rÃ©cupÃ©rÃ©e pour {symbol}")
            except Exception as e:
                logger.error(f"âŒ Erreur lors de la rÃ©cupÃ©ration des news: {e}")
            
            # RÃ©sumÃ© des tests
            logger.info("\n----- RÃ‰SUMÃ‰ DES TESTS -----")
            
            if results[mode]["connection"]:
                logger.info(f"âœ… Connexion au mode {mode.upper()}: RÃ©ussie")
            else:
                logger.error(f"âŒ Connexion au mode {mode.upper()}: Ã‰chec")
                
            if results[mode]["account_info"]:
                logger.info(f"âœ… Informations du compte: Disponibles")
            else:
                logger.error(f"âŒ Informations du compte: Non disponibles")
            
            logger.info(f"DonnÃ©es de marchÃ©:")
            for data_type, success in results[mode]["market_data"].items():
                status = "âœ… Disponible" if success else "âŒ Non disponible"
                logger.info(f"  - {data_type}: {status}")
            
            news_status = "âœ… Disponible" if results[mode]["news_data"] else "âŒ Non disponible"
            logger.info(f"DonnÃ©es de news: {news_status}")
            
            # Analyse de l'abonnement
            premium_features = sum([
                results[mode]["market_data"]["minute"],
                results[mode]["market_data"]["extended_history"],
                results[mode]["market_data"]["multiple_symbols"],
                results[mode]["news_data"]
            ])
            
            if premium_features >= 3:
                logger.info("ğŸŒŸ Votre compte semble avoir un abonnement premium!")
            elif premium_features >= 1:
                logger.info("â­ Votre compte semble avoir certaines fonctionnalitÃ©s premium.")
            else:
                logger.warning("âš ï¸ Votre compte ne semble pas avoir d'abonnement premium.")
            
        except Exception as e:
            logger.error(f"âŒ Erreur gÃ©nÃ©rale lors du test du mode {mode}: {e}")
    
    return results

if __name__ == "__main__":
    logger.info("\nğŸš€ DÃ‰MARRAGE DU TEST D'ABONNEMENT PREMIUM ALPACA")
    logger.info("Ce test va vÃ©rifier si votre abonnement Alpaca Ã  100$/mois fonctionne correctement")
    
    results = test_premium_features()
    
    logger.info("\n\nğŸ TEST TERMINÃ‰")
    logger.info("RÃ©capitulatif des fonctionnalitÃ©s premium dÃ©tectÃ©es:")
    
    for mode in results:
        premium_count = sum([
            results[mode]["market_data"]["minute"],
            results[mode]["market_data"]["extended_history"],
            results[mode]["market_data"]["multiple_symbols"],
            results[mode]["news_data"]
        ])
        
        if premium_count >= 3:
            status = "ğŸŒŸ PREMIUM"
        elif premium_count >= 1:
            status = "â­ PARTIEL"
        else:
            status = "âŒ STANDARD"
            
        logger.info(f"Mode {mode.upper()}: {status} ({premium_count}/4 fonctionnalitÃ©s premium)")
    
    logger.info("\nSi vous ne voyez pas toutes les fonctionnalitÃ©s premium, vÃ©rifiez que:")
    logger.info("1. Votre abonnement est bien activÃ© sur le compte Alpaca")
    logger.info("2. Les clÃ©s API utilisÃ©es correspondent au compte avec l'abonnement")
    logger.info("3. L'abonnement inclut bien les fonctionnalitÃ©s testÃ©es")



================================================
FILE: alpaca_test.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca API Access Test Script

This script tests access to Alpaca API to verify your credentials
and subscription are working correctly.
"""

import os
import sys
import json
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Configure logging
logging.basicConfig(level=logging.INFO, 
                    format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("Successfully imported alpaca-trade-api")
except ImportError:
    logger.error("Failed to import alpaca-trade-api. Trying to install it...")
    
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("Successfully installed and imported alpaca-trade-api")

def test_alpaca_access():
    """Test access to Alpaca API with current credentials"""
    
    # Load environment variables from .env file
    load_dotenv()
    
    # Check if we're using paper or live mode
    alpaca_mode = os.environ.get("ALPACA_MODE", "paper").lower()
    
    if alpaca_mode == "paper":
        api_key = os.environ.get("ALPACA_PAPER_KEY")
        api_secret = os.environ.get("ALPACA_PAPER_SECRET")
        base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
        logger.info("Testing Alpaca PAPER trading mode")
    else:
        api_key = os.environ.get("ALPACA_LIVE_KEY")
        api_secret = os.environ.get("ALPACA_LIVE_SECRET")
        base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
        logger.info("Testing Alpaca LIVE trading mode")
    
    if not api_key or not api_secret:
        logger.error(f"Alpaca API credentials for {alpaca_mode.upper()} mode not found in .env file")
        logger.info("Please check your .env file configuration")
        return False
    
    logger.info(f"Testing Alpaca API with key: {api_key[:4]}...{api_key[-4:]}")
    
    # Initialize Alpaca API
    try:
        # Connect to Alpaca API with specified credentials
        api = REST(
            key_id=api_key,
            secret_key=api_secret,
            base_url=base_url
        )
        logger.info(f"Successfully connected to Alpaca {alpaca_mode.upper()} Trading API")
        
        # Get account information
        account = api.get_account()
        logger.info(f"Account ID: {account.id}")
        logger.info(f"Account Status: {account.status}")
        logger.info(f"Portfolio Value: ${float(account.portfolio_value):.2f}")
        logger.info(f"Cash Balance: ${float(account.cash):.2f}")
        logger.info(f"Buying Power: ${float(account.buying_power):.2f}")
        
        # Check market data access
        try:
            # Test market data access with a well-known symbol
            symbol = 'AAPL'
            end = datetime.now()
            start = end - timedelta(days=5)
            
            # Format dates as ISO format strings
            start_str = start.date().isoformat()
            end_str = end.date().isoformat()
            
            # Get daily bar data
            logger.info(f"Attempting to get historical data for {symbol} from {start_str} to {end_str}")
            bars = api.get_bars(symbol, '1Day', start_str, end_str)
            
            if len(bars) > 0:
                logger.info(f"Successfully retrieved {len(bars)} bars of data")
                logger.info(f"Latest close price for {symbol}: ${bars[-1].c:.2f}")
                logger.info("Market data access is working correctly!")
            else:
                logger.warning(f"No data returned for {symbol}. This could be due to market holidays or data limitations.")
        
        except Exception as e:
            logger.error(f"Error accessing market data: {e}")
            logger.warning("Your Alpaca subscription might not include market data access")
            
        # Check subscription details
        try:
            # This will only work if the account has access to this endpoint
            account_configurations = api.get_account_configurations()
            logger.info("Successfully retrieved account configurations")
            logger.info(f"Account Configurations: {json.dumps(account_configurations.__dict__, indent=2)}")
        except Exception as e:
            logger.warning(f"Could not retrieve account configurations: {e}")
        
        # Check for active subscriptions
        logger.info("Your Alpaca account is active and working correctly!")
        return True
        
    except Exception as e:
        logger.error(f"Error connecting to Alpaca API: {e}")
        logger.error("Please check your API credentials and subscription status")
        return False

def test_data_subscription(api, alpaca_mode):
    """Test specific data subscription features"""
    logger.info("\n=== Testing Alpaca Data Subscription ===\n")
    
    try:
        # Testing real-time data by requesting market data
        # This is a specific feature of paid subscriptions
        symbol = 'AAPL'
        end = datetime.now()
        start = end - timedelta(days=60)  # Try for longer period to test subscription
        
        # Format dates as ISO format strings
        start_str = start.date().isoformat()
        end_str = end.date().isoformat()
        
        # Get minute data as this might be restricted to paid plans
        logger.info(f"Attempting to get 1-minute resolution data for {symbol} (last 7 days)")
        week_start = end - timedelta(days=7)
        week_start_str = week_start.date().isoformat()
        
        minute_bars = api.get_bars(symbol, '1Min', week_start_str, end_str)
        if len(minute_bars) > 0:
            logger.info(f"âœ… Successfully retrieved {len(minute_bars)} minute bars")
            logger.info(f"First bar: {minute_bars[0].__dict__}")
            logger.info(f"Last bar: {minute_bars[-1].__dict__}")
        else:
            logger.warning("âŒ No minute data retrieved, this might indicate a subscription limitation")
        
        # Test for fundamental data (if available in the subscription)
        try:
            logger.info("\nAttempting to access fundamental data...")
            
            # Try to access news API (often restricted to paid subscriptions)
            news = api.get_news(symbol)
            if news and len(news) > 0:
                logger.info(f"âœ… Successfully retrieved {len(news)} news items for {symbol}")
                logger.info(f"Latest news: {news[0].headline}")
            else:
                logger.warning("âŒ No news data retrieved, this might indicate a subscription limitation")
        except Exception as e:
            logger.warning(f"âŒ Could not access fundamental data: {e}")
            logger.warning("This might be restricted in your current subscription plan")
        
        # Test data for multiple symbols (batch request)
        try:
            symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']
            logger.info(f"\nTesting batch data for {len(symbols)} symbols...")
            
            batch_bars = api.get_bars(symbols, '1Day', start_str, end_str)
            if batch_bars and sum(len(bars) for symbol, bars in batch_bars.items()) > 0:
                logger.info(f"âœ… Successfully retrieved batch data for multiple symbols")
                for symbol, bars in batch_bars.items():
                    logger.info(f"  - {symbol}: {len(bars)} bars")
            else:
                logger.warning("âŒ Batch data retrieval failed or returned no data")
        except Exception as e:
            logger.warning(f"âŒ Batch data retrieval error: {e}")
            logger.warning("This might be restricted in your current subscription plan")
            
        return True
    except Exception as e:
        logger.error(f"Error testing data subscription: {e}")
        return False

if __name__ == "__main__":
    # Add command line arguments to choose between paper and live mode
    import argparse
    parser = argparse.ArgumentParser(description='Test Alpaca API access and subscription features')
    parser.add_argument('--mode', choices=['paper', 'live', 'both'], default='paper',
                       help='Trading mode to test: paper, live, or both (default: paper)')
    parser.add_argument('--data', action='store_true', help='Run additional tests for data subscription features')
    
    args = parser.parse_args()
    
    # Modify .env variable temporarily if testing both or specific mode
    if args.mode == 'both':
        modes = ['paper', 'live']
    else:
        modes = [args.mode]
    
    all_successful = True
    
    for mode in modes:
        logger.info(f"\n=== Alpaca API Access Test: {mode.upper()} MODE ===\n")
        
        # Override mode in environment
        os.environ['ALPACA_MODE'] = mode
        
        if test_alpaca_access():
            logger.info(f"âœ… Basic connectivity test for {mode.upper()} mode completed successfully!")
            
            # Test data subscription features if requested
            if args.data:
                # Get the current mode's API credentials
                load_dotenv()
                if mode == "paper":
                    api_key = os.environ.get("ALPACA_PAPER_KEY")
                    api_secret = os.environ.get("ALPACA_PAPER_SECRET")
                    base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
                else:
                    api_key = os.environ.get("ALPACA_LIVE_KEY")
                    api_secret = os.environ.get("ALPACA_LIVE_SECRET")
                    base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
                
                api = REST(key_id=api_key, secret_key=api_secret, base_url=base_url)
                test_data_subscription(api, mode)
        else:
            logger.error(f"âŒ Tests failed for {mode.upper()} mode. Please check the error messages above.")
            all_successful = False
    
    if all_successful:
        logger.info("\n=== SUMMARY ===\n")
        logger.info("âœ… All Alpaca API tests completed successfully!")
        logger.info("Your Alpaca subscription is working correctly.")
    else:
        logger.error("\n=== SUMMARY ===\n")
        logger.error("âŒ Some Alpaca API tests failed. Please check the error messages above.")
        logger.error("Your subscription might have limitations or configuration issues.")
        
    logger.info("\nTo test data subscription features more thoroughly, run:")
    logger.info("python alpaca_test.py --mode both --data")
    
    if 'live' in modes:
        logger.warning("\nNOTE: Tests included LIVE mode which connects to your real trading account.")
        logger.warning("      No trades were executed, but please verify the connection was successful.")




================================================
FILE: check_alpaca_plus.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
VÃ©rification de l'abonnement AlgoTrader Plus d'Alpaca
Ce script teste les fonctionnalitÃ©s spÃ©cifiques Ã  l'abonnement premium.
"""

import os
import sys
import logging
import json
from datetime import datetime, timedelta
from pprint import pprint
from dotenv import load_dotenv

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Chargement des variables d'environnement
load_dotenv()

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
except ImportError:
    logger.error("Installation de alpaca-trade-api...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST

def main():
    """Fonction principale pour vÃ©rifier l'abonnement AlgoTrader Plus"""
    
    # Utiliser les variables du fichier .env
    api_key = os.environ.get("ALPACA_PAPER_KEY")
    api_secret = os.environ.get("ALPACA_PAPER_SECRET")
    base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
    data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
    
    if not api_key or not api_secret:
        logger.error("ClÃ©s API Alpaca non dÃ©finies dans le fichier .env")
        return
        
    logger.info(f"Connexion Ã  Alpaca avec la clÃ©: {api_key[:4]}...{api_key[-4:]}")
    
    # Initialisation de l'API
    api = REST(
        key_id=api_key,
        secret_key=api_secret,
        base_url=base_url
    )
    
    try:
        # 1. VÃ©rifier les informations du compte et l'abonnement
        account = api.get_account()
        logger.info(f"ID du compte: {account.id}")
        logger.info(f"Statut du compte: {account.status}")
        
        try:
            # Tentative de rÃ©cupÃ©rer les dÃ©tails de l'abonnement (peut ne pas fonctionner)
            account_config = api.get_account_configurations()
            logger.info("Configuration du compte:")
            logger.info(json.dumps(account_config.__dict__, indent=2))
        except Exception as e:
            logger.warning(f"Impossible de rÃ©cupÃ©rer la configuration du compte: {e}")
        
        # 2. VÃ©rifier l'accÃ¨s aux donnÃ©es de marchÃ©
        # Symboles Ã  tester
        symbols = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA"]
        symbol = symbols[0]
        
        logger.info("\n==== TEST DES DONNÃ‰ES EN TEMPS RÃ‰EL ====")
        
        # 2.1 VÃ©rifier les donnÃ©es en temps rÃ©el
        try:
            logger.info(f"RÃ©cupÃ©ration du dernier prix pour {symbol}...")
            last_trade = api.get_latest_trade(symbol)
            logger.info(f"Dernier prix de {symbol}: ${last_trade.price:.2f}")
            logger.info(f"Horodatage: {last_trade.timestamp}")
            
            # VÃ©rifier si l'horodatage est rÃ©cent (moins de 15 min de retard)
            trade_time = datetime.fromisoformat(last_trade.timestamp.replace('Z', '+00:00'))
            delay = datetime.now() - trade_time.replace(tzinfo=None)
            logger.info(f"DÃ©lai des donnÃ©es: {delay.total_seconds() / 60:.2f} minutes")
            
            if delay.total_seconds() < 900:  # 15 minutes
                logger.info("âœ… DONNÃ‰ES EN TEMPS RÃ‰EL CONFIRMÃ‰ES")
            else:
                logger.warning("âš ï¸ Les donnÃ©es semblent Ãªtre retardÃ©es")
        except Exception as e:
            logger.error(f"Erreur lors de la rÃ©cupÃ©ration des derniers prix: {e}")
        
        logger.info("\n==== TEST DES DONNÃ‰ES HISTORIQUES PREMIUM ====")
        
        # 2.2 VÃ©rifier l'accÃ¨s aux donnÃ©es historiques Ã©tendues
        try:
            # Test sur 2 ans
            end = datetime.now()
            start = end - timedelta(days=365*2)
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"RÃ©cupÃ©ration des donnÃ©es historiques pour {symbol} du {start_str} au {end_str}...")
            bars = api.get_bars(symbol, '1Day', start_str, end_str)
            
            if bars and len(bars) > 0:
                logger.info(f"âœ… {len(bars)} jours de donnÃ©es historiques rÃ©cupÃ©rÃ©es")
                logger.info(f"Premier jour: {bars[0].t}")
                logger.info(f"Dernier jour: {bars[-1].t}")
                
                # Analyse de la pÃ©riode couverte
                first_date = datetime.fromisoformat(bars[0].t.replace('Z', '+00:00'))
                last_date = datetime.fromisoformat(bars[-1].t.replace('Z', '+00:00'))
                days_covered = (last_date - first_date).days
                
                logger.info(f"PÃ©riode couverte: {days_covered} jours")
                
                if days_covered > 700:  # ~2 ans
                    logger.info("âœ… HISTORIQUE Ã‰TENDU PREMIUM CONFIRMÃ‰")
                else:
                    logger.warning("âš ï¸ Historique limitÃ©, peut-Ãªtre pas d'accÃ¨s premium complet")
            else:
                logger.warning("Aucune donnÃ©e historique rÃ©cupÃ©rÃ©e")
        except Exception as e:
            logger.error(f"Erreur lors de la rÃ©cupÃ©ration des donnÃ©es historiques: {e}")
        
        # 2.3 VÃ©rifier l'accÃ¨s aux donnÃ©es Ã  haute rÃ©solution
        logger.info("\n==== TEST DES DONNÃ‰ES Ã€ HAUTE RÃ‰SOLUTION ====")
        try:
            # Test des donnÃ©es minutes
            end = datetime.now()
            start = end - timedelta(days=1)  # 1 jour
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"RÃ©cupÃ©ration des donnÃ©es minutes pour {symbol}...")
            minute_bars = api.get_bars(symbol, '1Min', start_str, end_str)
            
            if minute_bars and len(minute_bars) > 0:
                logger.info(f"âœ… {len(minute_bars)} barres de donnÃ©es minutes rÃ©cupÃ©rÃ©es")
                logger.info("âœ… DONNÃ‰ES Ã€ HAUTE RÃ‰SOLUTION CONFIRMÃ‰ES")
            else:
                logger.warning("Aucune donnÃ©e minute rÃ©cupÃ©rÃ©e")
        except Exception as e:
            logger.error(f"Erreur lors de la rÃ©cupÃ©ration des donnÃ©es minutes: {e}")
        
        # 2.4 VÃ©rifier l'accÃ¨s aux donnÃ©es de plusieurs symboles
        logger.info("\n==== TEST DES DONNÃ‰ES MULTI-SYMBOLES ====")
        try:
            end = datetime.now()
            start = end - timedelta(days=5)
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"RÃ©cupÃ©ration des donnÃ©es pour plusieurs symboles: {symbols}...")
            multi_bars = api.get_bars(symbols, '1Day', start_str, end_str)
            
            if multi_bars:
                symbol_count = len(multi_bars)
                logger.info(f"âœ… DonnÃ©es rÃ©cupÃ©rÃ©es pour {symbol_count} symboles:")
                for symbol, bars in multi_bars.items():
                    logger.info(f"  - {symbol}: {len(bars)} barres")
                
                if symbol_count >= 3:
                    logger.info("âœ… DONNÃ‰ES MULTI-SYMBOLES CONFIRMÃ‰ES")
            else:
                logger.warning("Aucune donnÃ©e multi-symboles rÃ©cupÃ©rÃ©e")
        except Exception as e:
            logger.error(f"Erreur lors de la rÃ©cupÃ©ration des donnÃ©es multi-symboles: {e}")
        
        # 3. VÃ©rifier l'accÃ¨s aux donnÃ©es fondamentales
        logger.info("\n==== TEST DES DONNÃ‰ES FONDAMENTALES ====")
        try:
            logger.info(f"RÃ©cupÃ©ration des donnÃ©es fondamentales pour {symbol}...")
            # Les news sont souvent incluses dans les abonnements premium
            news = api.get_news(symbol)
            
            if news and len(news) > 0:
                logger.info(f"âœ… {len(news)} articles de news rÃ©cupÃ©rÃ©s")
                logger.info(f"Dernier titre: {news[0].headline}")
                logger.info("âœ… DONNÃ‰ES DE NEWS CONFIRMÃ‰ES")
            else:
                logger.warning("Aucune donnÃ©e de news rÃ©cupÃ©rÃ©e")
        except Exception as e:
            logger.error(f"Erreur lors de la rÃ©cupÃ©ration des donnÃ©es fondamentales: {e}")
        
        # 4. RÃ©sumÃ© des rÃ©sultats
        logger.info("\n==== RÃ‰SUMÃ‰ DES TESTS ALGOTRADER PLUS ====")
        logger.info("Votre abonnement Alpaca AlgoTrader Plus a Ã©tÃ© testÃ© pour les fonctionnalitÃ©s suivantes:")
        logger.info("1. Compte et configuration")
        logger.info("2. DonnÃ©es en temps rÃ©el")
        logger.info("3. Historique Ã©tendu (2+ ans)")
        logger.info("4. DonnÃ©es Ã  haute rÃ©solution (minutes)")
        logger.info("5. DonnÃ©es multi-symboles")
        logger.info("6. DonnÃ©es fondamentales/news")
        
        logger.info("\nCes fonctionnalitÃ©s sont toutes disponibles dans votre abonnement AlgoTrader Plus.")
        logger.info("Mercurio AI est maintenant configurÃ© pour utiliser ces fonctionnalitÃ©s premium.")
    
    except Exception as e:
        logger.error(f"Erreur lors des tests Alpaca: {e}")

if __name__ == "__main__":
    logger.info("=== VÃ‰RIFICATION DE L'ABONNEMENT ALPACA ALGOTRADER PLUS ===")
    main()
    logger.info("=== FIN DES TESTS ===")



================================================
FILE: custom_strategy_lstm_params.json
================================================
{
  "strategy_type": "lstm",
  "params": {
    "sequence_length": 60,
    "prediction_horizon": 1,
    "lstm_units": 50,
    "dropout_rate": 0.2,
    "epochs": 50,
    "batch_size": 32,
    "use_gpu": true,
    "retrain": true,
    "position_size": 0.03,
    "stop_loss": 0.03,
    "take_profit": 0.06
  },
  "symbols": [
    "AAVE/USD",
    "AAVE/USDT",
    "AVAX/USD",
    "BAT/USD",
    "BCH/USD",
    "BCH/USDT",
    "BTC/USD",
    "BTC/USDT",
    "CRV/USD",
    "DOGE/USD",
    "DOGE/USDT",
    "DOT/USD",
    "ETH/USD",
    "ETH/USDT",
    "GRT/USD",
    "LINK/USD",
    "LINK/USDT",
    "LTC/USD",
    "LTC/USDT",
    "MKR/USD",
    "PEPE/USD",
    "SHIB/USD",
    "SOL/USD",
    "SUSHI/USD",
    "SUSHI/USDT",
    "TRUMP/USD",
    "UNI/USD",
    "UNI/USDT",
    "USDC/USD",
    "USDT/USD",
    "XRP/USD",
    "XTZ/USD",
    "YFI/USD",
    "YFI/USDT"
  ]
}


================================================
FILE: custom_strategy_mean_reversion_params.json
================================================
{
  "strategy_type": "mean_reversion",
  "params": {
    "lookback_period": 20,
    "position_size": 0.01,
    "stop_loss": 0.03,
    "take_profit": 0.06
  },
  "symbols": [
    "AAVE/USD",
    "AAVE/USDT",
    "AVAX/USD",
    "BAT/USD",
    "BCH/USD",
    "BCH/USDT",
    "BTC/USD",
    "BTC/USDT",
    "CRV/USD",
    "DOGE/USD",
    "DOGE/USDT",
    "DOT/USD",
    "ETH/USD",
    "ETH/USDT",
    "GRT/USD",
    "LINK/USD",
    "LINK/USDT",
    "LTC/USD",
    "LTC/USDT",
    "MKR/USD",
    "PEPE/USD",
    "SHIB/USD",
    "SOL/USD",
    "SUSHI/USD",
    "SUSHI/USDT",
    "TRUMP/USD",
    "UNI/USD",
    "UNI/USDT",
    "USDC/USD",
    "USDT/USD",
    "XRP/USD",
    "XTZ/USD",
    "YFI/USD",
    "YFI/USDT"
  ]
}


================================================
FILE: custom_strategy_transformer_params.json
================================================
{
  "strategy_type": "transformer",
  "params": {
    "sequence_length": 60,
    "prediction_horizon": 1,
    "d_model": 64,
    "nhead": 4,
    "num_layers": 2,
    "dropout": 0.1,
    "signal_threshold": 0.6,
    "use_gpu": false,
    "retrain": false,
    "position_size": 0.01,
    "stop_loss": 0.03,
    "take_profit": 0.06
  },
  "symbols": [
    "AAVE/USD",
    "AAVE/USDT",
    "AVAX/USD",
    "BAT/USD",
    "BCH/USD",
    "BCH/USDT",
    "BTC/USD",
    "BTC/USDT",
    "CRV/USD",
    "DOGE/USD",
    "DOGE/USDT",
    "DOT/USD",
    "ETH/USD",
    "ETH/USDT",
    "GRT/USD",
    "LINK/USD",
    "LINK/USDT",
    "LTC/USD",
    "LTC/USDT",
    "MKR/USD",
    "PEPE/USD",
    "SHIB/USD",
    "SOL/USD",
    "SUSHI/USD",
    "SUSHI/USDT",
    "TRUMP/USD",
    "UNI/USD",
    "UNI/USDT",
    "USDC/USD",
    "USDT/USD",
    "XRP/USD",
    "XTZ/USD",
    "YFI/USD",
    "YFI/USDT"
  ]
}


================================================
FILE: data_generator.py
================================================
"""
Mercurio AI - Data Generator

This module generates realistic market data for January 2025
to be used with the trading strategy simulations.
"""
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import os

def generate_market_data(symbol, start_date, end_date, initial_price=None, volatility=None):
    """
    Generate realistic OHLCV market data for a symbol.
    
    Args:
        symbol: The market symbol (e.g., 'AAPL', 'BTC-USD')
        start_date: Start date for generated data
        end_date: End date for generated data
        initial_price: Starting price (if None, uses a realistic default)
        volatility: Price volatility (if None, uses realistic default based on symbol)
    
    Returns:
        DataFrame with columns: date, open, high, low, close, volume
    """
    # Set realistic initial prices and volatility if not provided
    if initial_price is None:
        price_defaults = {
            'AAPL': 190.0, 'MSFT': 410.0, 'GOOGL': 160.0, 'AMZN': 180.0, 'TSLA': 175.0,
            'BTC-USD': 42000.0, 'ETH-USD': 2200.0, 'SOL-USD': 95.0, 'ADA-USD': 0.45, 'DOT-USD': 7.0
        }
        initial_price = price_defaults.get(symbol, 100.0)
    
    if volatility is None:
        # Higher volatility for crypto
        if '-USD' in symbol:
            volatility = 0.025  # 2.5% daily volatility for crypto
        else:
            volatility = 0.015  # 1.5% daily volatility for stocks
    
    # Generate date range (exclude weekends for stocks)
    date_range = []
    current_date = start_date
    is_crypto = '-USD' in symbol
    
    while current_date <= end_date:
        # For stocks, skip weekends
        if is_crypto or current_date.weekday() < 5:  # 0-4 are Monday to Friday
            date_range.append(current_date)
        current_date += timedelta(days=1)
    
    # Ensure at least 3 rows of data for simulation
    min_rows = 3
    if len(date_range) < min_rows:
        # Extend backwards in time if needed
        print(f"[WARNING] Not enough data points for {symbol} between {start_date} and {end_date}. Auto-extending date range to ensure at least {min_rows} data points.")
        needed = min_rows - len(date_range)
        ext_date = (date_range[0] if date_range else end_date)
        ext_dates = []
        while len(ext_dates) < needed:
            ext_date = ext_date - timedelta(days=1)
            if is_crypto or ext_date.weekday() < 5:
                ext_dates.insert(0, ext_date)
        date_range = ext_dates + date_range
    
    # Generate price data using geometric Brownian motion
    n_days = len(date_range)
    returns = np.random.normal(0, volatility, n_days)
    
    # Add a slight drift (upward bias for January 2025)
    drift = 0.001  # 0.1% daily drift
    returns = returns + drift
    
    # Calculate price series
    prices = [initial_price]
    for ret in returns[1:]:
        prices.append(prices[-1] * (1 + ret))
    
    # Generate realistic OHLCV data
    data = []
    for i, date in enumerate(date_range):
        close_price = prices[i]
        high_low_range = close_price * volatility * 1.5
        
        # Ensure first day price matches initial_price for the close
        if i == 0:
            close_price = initial_price
            
        open_price = prices[i-1] if i > 0 else close_price * (1 - volatility/2)
        high_price = max(open_price, close_price) + np.random.uniform(0, high_low_range)
        low_price = min(open_price, close_price) - np.random.uniform(0, high_low_range)
        
        # Generate volume (higher for more volatile days)
        price_change = abs(close_price - open_price)
        base_volume = close_price * 1000  # Base volume proportional to price
        volume = int(base_volume * (1 + 5 * price_change / close_price))
        
        data.append({
            'date': date,
            'open': open_price,
            'high': high_price,
            'low': low_price,
            'close': close_price,
            'volume': volume
        })
    
    df = pd.DataFrame(data)
    df.set_index('date', inplace=True)
    
    return df

def save_market_data(symbol, data, directory='data'):
    """Save market data to CSV file."""
    os.makedirs(directory, exist_ok=True)
    filename = os.path.join(directory, f"{symbol.replace('-', '_')}_data.csv")
    data.to_csv(filename)
    print(f"Saved data for {symbol} to {filename}")
    return filename

def generate_all_market_data(symbols, start_date, end_date, directory='data'):
    MIN_ROWS = 10
    for symbol in symbols:
        print(f"Generating data for {symbol}...")
        data = generate_market_data(symbol, start_date, end_date)
        tries = 0
        while (data is None or len(data) < MIN_ROWS) and tries < 5:
            start_date = start_date - timedelta(days=5)
            data = generate_market_data(symbol, start_date, end_date)
            tries += 1
        if data is not None and len(data) >= MIN_ROWS:
            filename = os.path.join(directory, f"{symbol.replace('-', '_')}_data.csv")
            data.to_csv(filename)
            print(f"Saved data for {symbol} to {filename}")
        else:
            print(f"Failed to generate sufficient data for {symbol} (rows: {len(data) if data is not None else 0})")

def load_market_data(symbol, directory='data'):
    """Load market data from CSV file."""
    filename = os.path.join(directory, f"{symbol.replace('-', '_')}_data.csv")
    if os.path.exists(filename):
        data = pd.read_csv(filename)
        data['date'] = pd.to_datetime(data['date'])
        data.set_index('date', inplace=True)
        return data
    else:
        return None

if __name__ == "__main__":
    # Test the data generator
    symbols = ['AAPL', 'MSFT', 'GOOGL', 'BTC-USD', 'ETH-USD']
    start_date = datetime(2025, 1, 1)
    end_date = datetime(2025, 1, 31)
    
    files = generate_all_market_data(symbols, start_date, end_date)
    print(f"Generated data files: {files}")
    
    # Load and display sample data
    aapl_data = load_market_data('AAPL')
    if aapl_data is not None:
        print("\nSample AAPL data:")
        print(aapl_data.head())



================================================
FILE: docker-compose.yml
================================================
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - ./:/app
    depends_on:
      - postgres
      - redis
    env_file:
      - .env
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres:5432/mercurio
      - REDIS_URL=redis://redis:6379/0
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

  worker:
    build: .
    volumes:
      - ./:/app
    depends_on:
      - postgres
      - redis
    env_file:
      - .env
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres:5432/mercurio
      - REDIS_URL=redis://redis:6379/0
    command: celery -A app.tasks.celery_app worker --loglevel=info

  beat:
    build: .
    volumes:
      - ./:/app
    depends_on:
      - postgres
      - redis
    env_file:
      - .env
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres:5432/mercurio
      - REDIS_URL=redis://redis:6379/0
    command: celery -A app.tasks.celery_app beat --loglevel=info

  flower:
    build: .
    ports:
      - "5555:5555"
    volumes:
      - ./:/app
    depends_on:
      - postgres
      - redis
    env_file:
      - .env
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres:5432/mercurio
      - REDIS_URL=redis://redis:6379/0
    command: celery -A app.tasks.celery_app flower

  postgres:
    image: postgres:15
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=mercurio

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:



================================================
FILE: Dockerfile
================================================
FROM python:3.11-slim

WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create directories
RUN mkdir -p ./logs ./data ./models

# Expose port
EXPOSE 8000

# Command to run the application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]



================================================
FILE: lingest
================================================
(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
<div align="center">
  <h1>ğŸš€ Mercurio Systems Trading Platform</h1>
  <p><strong>The intelligent, resilient algorithmic trading platform that adapts to any market condition</strong></p>
  <p>
    <a href="#installation"><img src="https://img.shields.io/badge/Installation-Guide-blue"/></a>
    <a href="#quick-start"><img src="https://img.shields.io/badge/Quick-Start-brightgreen"/></a>
    <a href="docs/for-dummies/01-introduction.md"><img src="https://img.shields.io/badge/Documentation-Complete-orange"/></a>
    <a href="https://mercurio.systems"><img src="https://img.shields.io/badge/Website-https%3A%2F%2Fmercurio.systems-blue"/></a>
    <a href="https://github.com/deepload/Mercurio"><img src="https://img.shields.io/badge/GitHub-https%3A%2F%2Fgithub.com%2Fdeepload%2FMercurio-blue"/></a>
    <a href="LICENSE"><img src="https://img.shields.io/badge/License-MIT-yellow"/></a>
  </p>
</div>

## ğŸ’¼ Overview

Mercurio is a comprehensive algorithmic trading platform built with reliability and versatility at its core. Whether you're a beginner exploring trading strategies or an expert deploying sophisticated machine learning models, Mercurio provides all the tools you need in one integrated ecosystem.

### ğŸŒŸ Key Features

- **Multiple Strategy Types**: From simple moving averages to advanced ML models (LSTM, Transformer, LLM)
- **Fallback Mechanisms**: Test and trade without API keys using our multi-layered fallback system
- **Paper Trading Mode**: Practice risk-free with simulated trading
- **Comprehensive Backtesting**: Evaluate strategies against historical data
- **Interactive Dashboards**: Monitor performance with Streamlit-powered visualizations
- **Asset Diversity**: Trade stocks and cryptocurrencies (BTC-USD, ETH-USD, etc.) across multiple timeframes
- **Resilient Architecture**: Ensures continuous operation even during outages

## ğŸ“‚ Project Structure

<details>
<summary><strong>Click to expand project structure</strong></summary>

```
Mercurio/
â”œâ”€â”€ app/                       # Core application directory
â”‚   â”œâ”€â”€ main.py                # FastAPI application entry point
â”‚   â”œâ”€â”€ api/                   # API endpoints
â”‚   â”‚   â”œâ”€â”€ routes.py          # API route definitions
â”‚   â”‚   â””â”€â”€ schemas.py         # Pydantic models for requests/responses
â”‚   â”œâ”€â”€ services/              # Business logic services
â”‚   â”‚   â”œâ”€â”€ market_data.py     # Service for fetching market data
â”‚   â”‚   â”œâ”€â”€ trading.py         # Service for executing trades
â”‚   â”‚   â””â”€â”€ backtesting.py     # Service for backtesting strategies
â”‚   â”œâ”€â”€ strategies/            # Trading strategies
â”‚   â”‚   â”œâ”€â”€ base.py            # Base strategy class
â”‚   â”‚   â”œâ”€â”€ moving_average.py  # Moving Average Crossover strategy
â”‚   â”‚   â”œâ”€â”€ lstm_predictor.py  # LSTM-based prediction strategy
â”‚   â”‚   â”œâ”€â”€ transformer.py     # Transformer-based strategy
â”‚   â”‚   â”œâ”€â”€ llm_strategy.py    # LLM-powered strategy
â”‚   â”‚   â””â”€â”€ msi_strategy.py    # Market Sentiment Index strategy
â”‚   â”œâ”€â”€ db/                    # Database modules
â”‚   â”‚   â”œâ”€â”€ database.py        # Database connection
â”‚   â”‚   â””â”€â”€ models.py          # SQLAlchemy models
â”‚   â”œâ”€â”€ tasks/                 # Celery tasks
â”‚   â”‚   â”œâ”€â”€ celery_app.py      # Celery configuration
â”‚   â”‚   â”œâ”€â”€ training.py        # Tasks for model training
â”‚   â”‚   â”œâ”€â”€ trading.py         # Tasks for automated trading
â”‚   â”‚   â””â”€â”€ data.py            # Tasks for data collection
â”‚   â””â”€â”€ utils/                 # Utility functions
â”œâ”€â”€ docs/                      # Documentation directory
â”‚   â”œâ”€â”€ for-dummies/           # Comprehensive guide for beginners
â”‚   â”œâ”€â”€ guides/                # Specialized guides
â”‚   â”‚   â”œâ”€â”€ beginner/          # Beginner guides
â”‚   â”‚   â””â”€â”€ advanced/          # Advanced guides
â”‚   â”œâ”€â”€ api/                   # API documentation
â”‚   â”œâ”€â”€ reference/             # Technical reference
â”‚   â””â”€â”€ README.md              # Documentation index
â”œâ”€â”€ models/                    # Saved ML models
â”‚   â”œâ”€â”€ lstm/                  # LSTM models and scalers
â”‚   â””â”€â”€ transformer/           # Transformer models and scalers
â”œâ”€â”€ data/                      # Data directory
â”‚   â””â”€â”€ sample_data/           # Sample data for testing
â”œâ”€â”€ reports/                   # Reports and visualizations
â”‚   â”œâ”€â”€ comprehensive/         # Comprehensive simulation results
â”‚   â””â”€â”€ visualizations/        # Generated charts and graphs
â”œâ”€â”€ tests/                     # Tests directory
â”œâ”€â”€ comprehensive_simulation.py # Full-featured simulation script
â”œâ”€â”€ strategy_dashboard.py      # Streamlit dashboard for strategy visualization
â”œâ”€â”€ docker-compose.yml         # Docker Compose configuration
â”œâ”€â”€ Dockerfile                 # Docker configuration
â”œâ”€â”€ requirements.txt           # Python dependencies
â”œâ”€â”€ .env.example              # Example environment variables
â””â”€â”€ README.md                 # This file (you are here)
```
</details>

## ğŸš€ Getting Started

### Prerequisites

<table>
  <tr>
    <td><strong>Required</strong></td>
    <td>
      â€¢ Python 3.11 or later<br>
      â€¢ Git
    </td>
  </tr>
  <tr>
    <td><strong>Optional</strong></td>
    <td>
      â€¢ Docker and Docker Compose (for containerized deployment)<br>
      â€¢ Polygon.io API key (for production-quality market data)<br>
      â€¢ Alpaca Paper Trading API keys (for risk-free paper trading)<br>
      â€¢ Alpaca Live Trading API keys (for real money trading)<br>
    </td>
  </tr>
  <tr>
    <td><strong>Note</strong></td>
    <td>Thanks to Mercurio's fallback system, no API keys are required to get started with testing and development!</td>
  </tr>
</table>

### ğŸ’» Installation

<details open>
<summary><strong>Standard Installation</strong></summary>

```bash
# Clone the repository
git clone https://github.com/deepload/Mercurio
cd mercurio-systems

# Create and activate virtual environment
python -m venv venv
venv\Scripts\activate  # On Windows
# source venv/bin/activate  # On Unix/MacOS

# Install dependencies
pip install -r requirements.txt

# Set up environment variables (optional for testing)
copy .env.example .env
# Edit .env with your API keys if available
# For Alpaca, configure both paper and live trading modes:
```
</details>

<details>
<summary><strong>Docker Installation</strong></summary>

```bash
# Clone the repository
git clone https://github.com/deepload/Mercurio
cd mercurio-systems

# Create environment file
copy .env.example .env
# Edit .env with your configuration

# Start the services
docker-compose up -d
```

The following services will be available:
- API: http://localhost:8000
- Swagger UI: http://localhost:8000/docs
- Flower (Celery monitoring): http://localhost:5555
</details>

## ğŸƒâ€â™‚ï¸ Quick Start

### 1. Run a Simple Strategy

```python
# simple_strategy.py
from app.services.market_data import MarketDataService
from app.strategies.moving_average import MovingAverageStrategy
import asyncio

async def run_simple_strategy():
    # Initialize services with fallback enabled
    market_data = MarketDataService(use_fallback=True)
    strategy = MovingAverageStrategy(short_window=10, long_window=30)
    
    # Get historical data (falls back to sample data if needed)
    data = await market_data.get_historical_data("AAPL", "2024-01-01", "2024-03-01")
    
    # Process data and generate signals
    processed_data = await strategy.preprocess_data(data)
    signal, confidence = await strategy.predict(processed_data)
    
    print(f"AAPL Trading Signal: {signal} (Confidence: {confidence:.2f})")

if __name__ == "__main__":
    asyncio.run(run_simple_strategy())
```

Run the script:
```bash
python simple_strategy.py
```

### 2. Launch the Interactive Dashboard

```bash
streamlit run strategy_dashboard.py
```

This will open a browser window with an interactive dashboard to explore strategy performance.

### 3. Run a Comprehensive Simulation

```bash
python comprehensive_simulation.py --timeframe daily
```

## ğŸ”Œ API Reference

<details>
<summary><strong>Available API Endpoints</strong></summary>

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/strategies` | GET | List all available trading strategies |
| `/api/strategies/{strategy_name}` | GET | Get details about a specific strategy |
| `/api/predictions/{strategy_name}/{symbol}` | POST | Get a prediction for a symbol |
| `/api/backtests` | POST | Run a backtest for a strategy |
| `/api/backtests/{backtest_id}` | GET | Get backtest results |
| `/api/models/train` | POST | Train a strategy model |
| `/api/models/{model_id}` | GET | Get model details |
| `/api/trades` | POST | Execute a trade |
| `/api/account` | GET | Get account information |
| `/api/market/status` | GET | Check market status |

For complete API documentation, run the server and visit `/docs` or check the [API Reference](./docs/api/README.md).
</details>

## ğŸ”§ Extending Mercurio Systems

### Creating Custom Strategies

<details>
<summary><strong>Click to see how to add custom strategies</strong></summary>

Mercurio Systems follows a plugin architecture for strategies, making it easy to implement your own trading logic:

1. Create a new Python file in the `app/strategies` directory
2. Extend the `BaseStrategy` class
3. Implement required methods

```python
from app.strategies.base import BaseStrategy
import pandas as pd
import numpy as np

class MyCustomStrategy(BaseStrategy):
    """My custom mean-reversion trading strategy"""
    
    def __init__(self, lookback_period=20, threshold=2.0):
        self.lookback_period = lookback_period
        self.threshold = threshold
        self.name = "MeanReversionStrategy"
        self.description = "Buys oversold assets and sells overbought assets"
        
    async def preprocess_data(self, data):
        """Calculate z-scores for mean reversion"""
        df = data.copy()
        
        # Calculate rolling mean and standard deviation
        df['rolling_mean'] = df['close'].rolling(window=self.lookback_period).mean()
        df['rolling_std'] = df['close'].rolling(window=self.lookback_period).std()
        
        # Calculate z-score
        df['z_score'] = (df['close'] - df['rolling_mean']) / df['rolling_std']
        
        return df.dropna()
        
    async def predict(self, data):
        """Generate trading signals based on z-scores"""
        if data.empty or len(data) < self.lookback_period:
            return "HOLD", 0.0
            
        current_z = data.iloc[-1]['z_score']
        
        # Mean reversion logic
        if current_z < -self.threshold:
            # Oversold, potential buy
            signal = "BUY"
            confidence = min(abs(current_z) / 4, 1.0)  # Normalize confidence
        elif current_z > self.threshold:
            # Overbought, potential sell
            signal = "SELL"
            confidence = min(abs(current_z) / 4, 1.0)  # Normalize confidence
        else:
            signal = "HOLD"
            confidence = 1.0 - (abs(current_z) / self.threshold)
            
        return signal, float(confidence)
```

Register your strategy in `app/strategies/__init__.py` to make it available throughout the system.
</details>

### Custom Data Sources

<details>
<summary><strong>Click to see how to add custom data sources</strong></summary>

Extend the `BaseDataProvider` class to integrate with any market data source:

```python
from app.services.data_providers.base import BaseDataProvider
import pandas as pd
import requests

class MyCustomDataProvider(BaseDataProvider):
    """Custom data provider for XYZ market data"""
    
    def __init__(self, api_key=None):
        self.api_key = api_key
        self.base_url = "https://api.example.com/v1"
        
    async def get_historical_data(self, symbol, start_date, end_date, timeframe="1d"):
        """Fetch historical market data from custom source"""
        # Implementation
        headers = {"Authorization": f"Bearer {self.api_key}"} if self.api_key else {}
        params = {
            "symbol": symbol,
            "from": start_date,
            "to": end_date,
            "interval": timeframe
        }
        
        response = requests.get(f"{self.base_url}/historical", headers=headers, params=params)
        data = response.json()
        
        # Transform to standard format
        df = pd.DataFrame(data["bars"])
        df.columns = ["timestamp", "open", "high", "low", "close", "volume"]
        df["timestamp"] = pd.to_datetime(df["timestamp"])
        df.set_index("timestamp", inplace=True)
        
        return df
```
</details>

## ğŸ”¬ Running the Comprehensive Simulation

Test all available strategies across different assets and timeframes:

```bash
python comprehensive_simulation.py --start-date 2024-03-03 --end-date 2025-04-25 --initial-capital 10000
```

This runs a full-year simulation using:
- **5 Stock Assets**: AAPL, MSFT, GOOGL, AMZN, TSLA
- **5 Crypto Assets**: BTC-USD, ETH-USD, SOL-USD, ADA-USD, DOT-USD
- **All Strategies**: MovingAverage, LSTM, Transformer, LLM, MSI
- **Multiple Timeframes**: Daily, Weekly, Monthly

Results are saved to the `reports/comprehensive/` directory with full metrics and visualizations.

## ğŸ“š Documentation

Comprehensive documentation is available in the [docs](./docs) directory:

### ğŸ“” Guides Principaux

- **[ğŸ” Index des Guides](./docs/GUIDES_INDEX.md)**: Point d'entrÃ©e central avec tous les guides disponibles
- **[ğŸ“ˆ Guide de Day Trading](./docs/day_trading_guide.md)**: SystÃ¨me automatisÃ© de day trading sur actions et crypto
- **[ğŸ“Š Guide des Options](./docs/options_trading.md)**: Trading d'options avec Mercurio AI
- **[ğŸ§  Guide d'EntraÃ®nement des ModÃ¨les](./docs/model_training_guide.md)**: CrÃ©er et entraÃ®ner des modÃ¨les d'IA

### ğŸ“– Documentation GÃ©nÃ©rale

- **[ğŸ“š Pour les DÃ©butants](./docs/for-dummies/README.md)**: Guide complet en 12 chapitres pour dÃ©butants
- **[ğŸ”° Guides DÃ©butants](./docs/guides/beginner/)**: Ressources pour dÃ©marrer rapidement
- **[ğŸ”§ Guides AvancÃ©s](./docs/guides/advanced/)**: Sujets spÃ©cialisÃ©s pour traders expÃ©rimentÃ©s
- **[ğŸ“ Documentation RÃ©fÃ©rence](./docs/reference/)**: DÃ©tails techniques et spÃ©cifications API

## ğŸ§ª Testing

```bash
# Run the test suite
pytest

# Run tests with coverage
pytest --cov=app
```

## ğŸ¤ Contributing

Contributions are welcome! Check out the [contribution guidelines](CONTRIBUTING.md) to get started.

## ğŸ“„ License

This project is open-source and available under the MIT License.

## ğŸŒŸ Showcase

<div align="center">
  <table>
    <tr>
      <td align="center"><img src="https://i.imgur.com/2sGSK1h.png" width="400"/><br><b>Strategy Comparison</b></td>
      <td align="center"><img src="https://i.imgur.com/7fVLnMF.png" width="400"/><br><b>Portfolio Allocation</b></td>
    </tr>
  </table>
</div>

## ğŸ™ Acknowledgements

- [FastAPI](https://fastapi.tiangolo.com/)
- [SQLAlchemy](https://www.sqlalchemy.org/)
- [PyTorch](https://pytorch.org/)
- [Pandas](https://pandas.pydata.org/)
- [Streamlit](https://streamlit.io/)
- [Polygon.io](https://polygon.io/)
- [Yahoo Finance](https://finance.yahoo.com/)
- [Alpaca Markets](https://alpaca.markets/)
- [Backtrader](https://www.backtrader.com/)



================================================
FILE: alpaca_crypto_trader.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca Crypto Day Trading Script
--------------------------------
Script autonome pour le daytrading de cryptomonnaies via Alpaca API,
optimisÃ© pour l'abonnement de niveau 3 (AlgoTrader Plus).

Utilisation:
    python alpaca_crypto_trader.py --duration 1h --log-level INFO
"""

import os
import time
import signal
import logging
import argparse
import asyncio
from enum import Enum
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta

# API Alpaca
import alpaca_trade_api as tradeapi
import pandas as pd
from dotenv import load_dotenv

# Chargement des variables d'environnement
load_dotenv()

# Configuration du logger
# Configurer la journalisation pour enregistrer dans un fichier
log_file = f"crypto_trader_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("alpaca_crypto_trader")

# Variables globales pour la gestion des signaux
running = True
session_end_time = None

# Enums pour la durÃ©e de session
class SessionDuration(int, Enum):
    ONE_HOUR = 3600
    FOUR_HOURS = 14400
    EIGHT_HOURS = 28800
    NIGHT_RUN = 32400  # 9 heures (pour couvrir toute la nuit)
    CUSTOM = 0

class AlpacaCryptoTrader:
    """
    SystÃ¨me de daytrading crypto utilisant directement l'API Alpaca
    
    CaractÃ©ristiques:
    - Utilise l'API Alpaca pour trader des cryptos en mode paper
    - StratÃ©gie simple de croisement de moyennes mobiles
    - Plusieurs durÃ©es de session (1h, 4h, 8h, nuit)
    - ParamÃ¨tres de trading configurables
    - Journalisation complÃ¨te et rapport de performance
    """
    
    def __init__(self, session_duration: SessionDuration = SessionDuration.ONE_HOUR):
        """Initialiser le systÃ¨me de trading crypto"""
        self.session_duration = session_duration
        
        # DÃ©terminer le mode Alpaca (paper ou live)
        alpaca_mode = os.getenv("ALPACA_MODE", "paper").lower()
        
        # Configuration selon le mode
        if alpaca_mode == "live":
            self.api_key = os.getenv("ALPACA_LIVE_KEY")
            self.api_secret = os.getenv("ALPACA_LIVE_SECRET")
            self.base_url = os.getenv("ALPACA_LIVE_URL", "https://api.alpaca.markets")
            logger.info("ConfigurÃ© pour le trading LIVE (rÃ©el)")
        else:  # mode paper par dÃ©faut
            self.api_key = os.getenv("ALPACA_PAPER_KEY")
            self.api_secret = os.getenv("ALPACA_PAPER_SECRET")
            self.base_url = os.getenv("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
            logger.info("ConfigurÃ© pour le trading PAPER (simulation)")
            
        # URL des donnÃ©es de marchÃ©
        self.data_url = os.getenv("ALPACA_DATA_URL", "https://data.alpaca.markets")
        
        # Niveau d'abonnement Alpaca
        self.subscription_level = int(os.getenv("ALPACA_SUBSCRIPTION_LEVEL", "1"))
        logger.info(f"Utilisation du niveau d'abonnement Alpaca: {self.subscription_level}")
        
        # Client API Alpaca
        self.api = None
        
        # ParamÃ¨tres de trading
        self.symbols = []  # Sera rempli avec les symboles crypto disponibles
        self.custom_symbols = []  # Liste personnalisÃ©e de symboles Ã  utiliser
        self.use_custom_symbols = False  # Si True, utilise custom_symbols au lieu de la liste filtrÃ©e
        self.fast_ma_period = 5   # 5 minutes pour la moyenne mobile rapide
        self.slow_ma_period = 15  # 15 minutes pour la moyenne mobile lente
        self.position_size_pct = 0.02  # 2% du portefeuille par position
        self.stop_loss_pct = 0.03  # 3% de stop loss
        self.take_profit_pct = 0.06  # 6% de prise de profit
        
        # Suivi de l'Ã©tat
        self.positions = {}
        self.portfolio_value = 0.0
        self.initial_portfolio_value = 0.0
        self.session_start_time = None
        self.session_end_time = None
        self.trade_history = []  # Pour enregistrer l'historique des transactions
        
        logger.info("AlpacaCryptoTrader initialisÃ©")
        
    def initialize(self):
        """Initialiser les services et charger la configuration"""
        try:
            # Initialiser le client API Alpaca
            self.api = tradeapi.REST(
                key_id=self.api_key,
                secret_key=self.api_secret,
                base_url=self.base_url,
                api_version='v2'
            )
            
            # VÃ©rifier que le client est correctement initialisÃ©
            account = self.api.get_account()
            if account:
                self.portfolio_value = float(account.portfolio_value)
                self.initial_portfolio_value = self.portfolio_value
                logger.info(f"Compte Alpaca connectÃ©: {account.id}")
                logger.info(f"Valeur initiale du portefeuille: ${self.portfolio_value:.2f}")
                logger.info(f"Mode trading: {account.status}")
                
                # VÃ©rifier la disponibilitÃ© du trading crypto
                assets = self.api.list_assets(asset_class='crypto')
                
                if not self.use_custom_symbols:
                    # Filtrer pour ne garder que les paires USD pures (exclure explicitement USDT/USDC)
                    self.symbols = [asset.symbol for asset in assets if asset.tradable 
                                  and '/USD' in asset.symbol 
                                  and not '/USDT' in asset.symbol 
                                  and not '/USDC' in asset.symbol]
                    
                    if self.symbols:
                        logger.info(f"TrouvÃ© {len(self.symbols)} symboles crypto disponibles (USD seulement)")
                        logger.info(f"Exemples: {', '.join(self.symbols[:5])}")
                    else:
                        logger.warning("Aucun symbole crypto disponible avec USD")
                else:
                    # Utiliser la liste personnalisÃ©e et vÃ©rifier que les symboles sont tradables
                    tradable_assets = [asset.symbol for asset in assets if asset.tradable]
                    self.symbols = [symbol for symbol in self.custom_symbols if symbol in tradable_assets]
                    logger.info(f"Utilisation d'une liste personnalisÃ©e de {len(self.symbols)} symboles crypto")
                    if self.symbols:
                        logger.info(f"Exemples: {', '.join(self.symbols[:5])}")
                    else:
                        logger.warning("Aucun symbole personnalisÃ© n'est tradable")
                    
                # VÃ©rifier le solde disponible en USD
                try:
                    account = self.api.get_account()
                    cash = float(account.cash)
                    logger.info(f"Solde USD disponible: ${cash:.2f}")
                except Exception as e:
                    logger.warning(f"Impossible de rÃ©cupÃ©rer le solde USD: {e}")
                    pass
                
                return True
            else:
                logger.error("Impossible de rÃ©cupÃ©rer les informations du compte")
                return False
                
        except Exception as e:
            logger.error(f"Erreur d'initialisation: {e}")
            return False
            
    def start(self, duration_seconds: Optional[int] = None):
        """DÃ©marrer la session de trading crypto"""
        self.session_start_time = datetime.now()
        
        if duration_seconds is not None:
            self.session_end_time = self.session_start_time + timedelta(seconds=duration_seconds)
        else:
            self.session_end_time = self.session_start_time + timedelta(seconds=int(self.session_duration))
            
        logger.info(f"DÃ©marrage de la session de trading crypto Ã  {self.session_start_time}")
        logger.info(f"La session se terminera Ã  {self.session_end_time}")
        
        # Initialiser le trader
        initialized = self.initialize()
        if not initialized:
            logger.error("Ã‰chec de l'initialisation, abandon")
            self.generate_performance_report()
            return
            
        # DÃ©marrer la boucle de trading
        self.trading_loop()
        
        # GÃ©nÃ©rer un rapport de performance Ã  la fin
        self.generate_performance_report()
            
    def trading_loop(self):
        """Boucle principale de trading"""
        global running
        
        try:
            while running and datetime.now() < self.session_end_time:
                # DÃ©terminer les symboles Ã  trader pour cette itÃ©ration
                # Limiter aux 10 premiÃ¨res cryptos pour Ã©viter les limites de taux si pas de liste personnalisÃ©e
                trading_symbols = self.symbols[:10] if (len(self.symbols) > 10 and not self.use_custom_symbols) else self.symbols
                
                # Traiter chaque symbole
                for symbol in trading_symbols:
                    try:
                        self.process_symbol(symbol)
                    except Exception as e:
                        logger.error(f"Erreur de traitement de {symbol}: {e}")
                
                # Mettre Ã  jour l'Ã©tat du portefeuille
                self.update_portfolio_state()
                
                # Attendre 60 secondes avant la prochaine itÃ©ration
                time_remaining = int((self.session_end_time - datetime.now()).total_seconds() / 60)
                logger.info(f"Attente de 60 secondes avant le prochain cycle. Fin de session dans {time_remaining} minutes")
                time.sleep(60)
                
        except Exception as e:
            logger.error(f"Erreur dans la boucle de trading: {e}")
        finally:
            logger.info("Boucle de trading terminÃ©e")
            
    def process_symbol(self, symbol: str):
        """Traiter un symbole de trading"""
        logger.info(f"Traitement de {symbol}")
        
        # Obtenir les donnÃ©es historiques (intervalles de 5 minutes pour les derniÃ¨res 24 heures)
        end = datetime.now()
        start = end - timedelta(days=1)
        
        try:
            # Formater les dates pour l'API
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            # Obtenir les barres de prix (corriger l'erreur expected list, str found)
            bars = self.api.get_crypto_bars(
                [symbol],  # Passer une liste au lieu d'une chaÃ®ne
                timeframe='5Min',
                start=start_str,
                end=end_str
            ).df
            
            if bars.empty:
                logger.warning(f"Pas de donnÃ©es historiques disponibles pour {symbol}")
                return
            
            # Si les donnÃ©es sont multi-index (symbole, timestamp), prendre juste le symbole concernÃ©
            if isinstance(bars.index, pd.MultiIndex):
                bars = bars.loc[symbol]
                
            # Calculer les moyennes mobiles
            bars['fast_ma'] = bars['close'].rolling(window=self.fast_ma_period).mean()
            bars['slow_ma'] = bars['close'].rolling(window=self.slow_ma_period).mean()
            
            # Obtenir la position actuelle
            position = None
            try:
                position = self.api.get_position(symbol)
            except:
                pass  # Pas de position existante
            
            # Obtenir le prix actuel (compatible avec abonnement niveau 1)
            try:
                # Pour le niveau 1, on peut utiliser la derniÃ¨re barre des derniÃ¨res 5 minutes comme prix actuel
                if not bars.empty:
                    current_price = float(bars.iloc[-1]['close'])
                    logger.info(f"{symbol} prix actuel (derniÃ¨re barre): ${current_price:.4f}")
                else:
                    logger.error(f"Pas de donnÃ©es disponibles pour obtenir le prix actuel de {symbol}")
                    return
            except Exception as e:
                logger.error(f"Impossible d'obtenir le prix actuel pour {symbol}: {e}")
                return
            
            # Logique de trading - Croisement de moyennes mobiles
            if len(bars) >= self.slow_ma_period:
                last_row = bars.iloc[-1]
                prev_row = bars.iloc[-2]
                
                # VÃ©rifier le signal d'achat: MA rapide croise au-dessus de la MA lente
                buy_signal = (
                    prev_row['fast_ma'] <= prev_row['slow_ma'] and 
                    last_row['fast_ma'] > last_row['slow_ma']
                )
                
                # VÃ©rifier le signal de vente: MA rapide croise en dessous de la MA lente
                sell_signal = (
                    prev_row['fast_ma'] >= prev_row['slow_ma'] and 
                    last_row['fast_ma'] < last_row['slow_ma']
                )
                
                # ExÃ©cuter les signaux
                if buy_signal and not position:
                    self.execute_buy(symbol, current_price)
                elif sell_signal and position:
                    self.execute_sell(symbol, current_price, position)
                
                # VÃ©rifier le stop loss et le take profit
                if position:
                    entry_price = float(position.avg_entry_price)
                    if entry_price > 0:
                        pnl_pct = (current_price - entry_price) / entry_price
                        
                        if pnl_pct <= -self.stop_loss_pct:
                            logger.info(f"{symbol} a atteint le stop loss Ã  {pnl_pct:.2%}")
                            self.execute_sell(symbol, current_price, position)
                        elif pnl_pct >= self.take_profit_pct:
                            logger.info(f"{symbol} a atteint le take profit Ã  {pnl_pct:.2%}")
                            self.execute_sell(symbol, current_price, position)
            
        except Exception as e:
            logger.error(f"Erreur de traitement de {symbol}: {e}")
    
    def execute_buy(self, symbol: str, price: float):
        """ExÃ©cuter un ordre d'achat"""
        try:
            # Calculer la taille de la position
            position_value = self.portfolio_value * self.position_size_pct
            qty = position_value / price
            
            logger.info(f"SIGNAL D'ACHAT: {symbol} Ã  ${price:.4f}, qtÃ©: {qty:.6f}")
            
            # Arrondir la quantitÃ© Ã  6 dÃ©cimales
            qty = round(qty, 6)
            
            # Placer un ordre au marchÃ©
            order = self.api.submit_order(
                symbol=symbol,
                qty=qty,
                side='buy',
                type='market',
                time_in_force='gtc'
            )
            
            if order:
                logger.info(f"Ordre d'achat placÃ© pour {symbol}: {order.id}")
                self.trade_history.append({
                    'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'symbol': symbol,
                    'action': 'achat',
                    'quantity': qty,
                    'price': price
                })
            else:
                logger.error(f"Ã‰chec du placement de l'ordre d'achat pour {symbol}")
                
        except Exception as e:
            logger.error(f"Erreur d'exÃ©cution d'achat pour {symbol}: {e}")
    
    def execute_sell(self, symbol: str, price: float, position):
        """ExÃ©cuter un ordre de vente"""
        try:
            qty = float(position.qty)
            
            if qty <= 0:
                logger.warning(f"QuantitÃ© de position invalide pour {symbol}: {qty}")
                return
                
            logger.info(f"SIGNAL DE VENTE: {symbol} Ã  ${price:.4f}, qtÃ©: {qty:.6f}")
            
            # Placer un ordre au marchÃ©
            order = self.api.submit_order(
                symbol=symbol,
                qty=qty,
                side='sell',
                type='market',
                time_in_force='gtc'
            )
            
            if order:
                logger.info(f"Ordre de vente placÃ© pour {symbol}: {order.id}")
                self.trade_history.append({
                    'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'symbol': symbol,
                    'action': 'vente',
                    'quantity': qty,
                    'price': price
                })
            else:
                logger.error(f"Ã‰chec du placement de l'ordre de vente pour {symbol}")
                
        except Exception as e:
            logger.error(f"Erreur d'exÃ©cution de vente pour {symbol}: {e}")
    
    def update_portfolio_state(self):
        """Mettre Ã  jour la valeur du portefeuille et les positions"""
        try:
            account = self.api.get_account()
            self.portfolio_value = float(account.portfolio_value)
            logger.info(f"Valeur actuelle du portefeuille: ${self.portfolio_value:.2f}")
            
            # Mettre Ã  jour les positions
            try:
                positions = self.api.list_positions()
                crypto_positions = [p for p in positions if '/' in p.symbol]
                
                # Journaliser les positions ouvertes
                if crypto_positions:
                    logger.info(f"Positions ouvertes actuelles: {len(crypto_positions)}")
                    for pos in crypto_positions:
                        entry_price = float(pos.avg_entry_price)
                        current_price = float(pos.current_price)
                        qty = float(pos.qty)
                        market_value = float(pos.market_value)
                        pnl = float(pos.unrealized_pl)
                        pnl_pct = float(pos.unrealized_plpc) * 100
                        
                        logger.info(f"  {pos.symbol}: {qty:.6f} @ ${entry_price:.4f} - Valeur: ${market_value:.2f} - P/L: ${pnl:.2f} ({pnl_pct:.2f}%)")
                else:
                    logger.info("Pas de positions ouvertes")
            except Exception as e:
                logger.error(f"Erreur de rÃ©cupÃ©ration des positions: {e}")
                
        except Exception as e:
            logger.error(f"Erreur de mise Ã  jour de l'Ã©tat du portefeuille: {e}")
    
    def generate_performance_report(self):
        """GÃ©nÃ©rer un rapport de performance Ã  la fin de la session de trading"""
        # CrÃ©er un fichier de rapport sÃ©parÃ©
        report_file = f"crypto_trading_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        try:
            end_time = datetime.now()
            duration = end_time - self.session_start_time if self.session_start_time else timedelta(0)
            hours, remainder = divmod(duration.seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            
            logger.info("===================================================")
            logger.info("RAPPORT DE PERFORMANCE DE LA SESSION DE TRADING CRYPTO")
            logger.info("===================================================")
            logger.info(f"DurÃ©e de la session: {hours}h {minutes}m {seconds}s")
            logger.info(f"Heure de dÃ©but: {self.session_start_time}")
            logger.info(f"Heure de fin: {end_time}")
            
            # Obtenir l'Ã©tat final du compte
            try:
                account = self.api.get_account()
                final_value = float(account.portfolio_value)
                
                if self.initial_portfolio_value > 0:
                    profit_loss = final_value - self.initial_portfolio_value
                    profit_loss_pct = (profit_loss / self.initial_portfolio_value) * 100
                    logger.info(f"Valeur initiale du portefeuille: ${self.initial_portfolio_value:.2f}")
                    logger.info(f"Valeur finale du portefeuille: ${final_value:.2f}")
                    logger.info(f"Profit/Perte: ${profit_loss:.2f} ({profit_loss_pct:.2f}%)")
            except Exception as e:
                logger.warning(f"Impossible de rÃ©cupÃ©rer les informations finales du compte: {e}")
            
            # Afficher les positions ouvertes
            try:
                positions = self.api.list_positions()
                crypto_positions = [p for p in positions if '/' in p.symbol]
                
                if crypto_positions:
                    logger.info(f"Positions ouvertes Ã  la fin de la session: {len(crypto_positions)}")
                    for pos in crypto_positions:
                        entry_price = float(pos.avg_entry_price)
                        current_price = float(pos.current_price)
                        qty = float(pos.qty)
                        market_value = float(pos.market_value)
                        pnl = float(pos.unrealized_pl)
                        pnl_pct = float(pos.unrealized_plpc) * 100
                        
                        logger.info(f"  {pos.symbol}: {qty:.6f} @ ${entry_price:.4f} - Valeur: ${market_value:.2f} - P/L: ${pnl:.2f} ({pnl_pct:.2f}%)")
                else:
                    logger.info("Pas de positions ouvertes Ã  la fin de la session")
            except Exception as e:
                logger.warning(f"Impossible de rÃ©cupÃ©rer les informations de position: {e}")
                
            logger.info("===================================================")
            logger.info("SESSION DE TRADING CRYPTO TERMINÃ‰E")
            logger.info("===================================================")
                
        except Exception as e:
            logger.error(f"Erreur de gÃ©nÃ©ration du rapport de performance: {e}")

        # Ã‰crire le rapport Ã©galement dans un fichier sÃ©parÃ©
        with open(report_file, 'w') as f:
            f.write("===================================================\n")
            f.write("RAPPORT DE PERFORMANCE DE LA SESSION DE TRADING CRYPTO\n")
            f.write("===================================================\n\n")
            f.write(f"DurÃ©e de la session: {hours}h {minutes}m {seconds}s\n")
            f.write(f"Heure de dÃ©but: {self.session_start_time}\n")
            f.write(f"Heure de fin: {end_time}\n\n")
            
            try:
                if self.initial_portfolio_value > 0:
                    f.write(f"Valeur initiale du portefeuille: ${self.initial_portfolio_value:.2f}\n")
                    f.write(f"Valeur finale du portefeuille: ${final_value:.2f}\n")
                    f.write(f"Profit/Perte: ${profit_loss:.2f} ({profit_loss_pct:.2f}%)\n\n")
            except:
                f.write("Impossible de rÃ©cupÃ©rer les informations finales du compte\n\n")
                
            f.write("Positions ouvertes Ã  la fin de la session:\n")
            try:
                if crypto_positions:
                    for pos in crypto_positions:
                        f.write(f"  {pos.symbol}: {float(pos.qty):.6f} @ ${float(pos.avg_entry_price):.4f} - ")
                        f.write(f"Valeur: ${float(pos.market_value):.2f} - ")
                        f.write(f"P/L: ${float(pos.unrealized_pl):.2f} ({float(pos.unrealized_plpc) * 100:.2f}%)\n")
                else:
                    f.write("Aucune position ouverte\n")
            except:
                f.write("Impossible de rÃ©cupÃ©rer les informations de position\n")
            
            f.write("\n===================================================\n")
            f.write("RÃ‰SUMÃ‰ DES TRANSACTIONS IMPORTANTES\n")
            f.write("===================================================\n")
            if hasattr(self, 'trade_history') and self.trade_history:
                for trade in self.trade_history:
                    f.write(f"{trade['time']} - {trade['symbol']} - {trade['action']} - ")
                    f.write(f"{trade['quantity']:.6f} @ ${trade['price']:.4f} - P/L: ${trade.get('pnl', 0):.2f}\n")
            else:
                f.write("Aucune transaction effectuÃ©e\n")
                
        logger.info(f"Rapport dÃ©taillÃ© sauvegardÃ© dans {report_file}")

def main():
    """Point d'entrÃ©e principal"""
    parser = argparse.ArgumentParser(description="SystÃ¨me de trading crypto Alpaca")
    parser.add_argument("--duration", type=str, choices=["1h", "4h", "8h", "custom"], default="1h",
                        help="DurÃ©e de la session de trading (1h, 4h, 8h, ou custom)")
    parser.add_argument("--custom-seconds", type=int, default=0,
                        help="DurÃ©e personnalisÃ©e en secondes si --duration=custom")
    parser.add_argument("--log-level", type=str, choices=["DEBUG", "INFO", "WARNING", "ERROR"], 
                        default="INFO", help="Niveau de journalisation")
                        
    args = parser.parse_args()
    
    # DÃ©finir le niveau de journalisation
    numeric_level = getattr(logging, args.log_level)
    logging.basicConfig(level=numeric_level, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
    
    # DÃ©terminer la durÃ©e de la session
    duration_map = {
        "1h": SessionDuration.ONE_HOUR,
        "4h": SessionDuration.FOUR_HOURS,
        "8h": SessionDuration.EIGHT_HOURS,
        "custom": SessionDuration.CUSTOM
    }
    session_duration = duration_map.get(args.duration, SessionDuration.ONE_HOUR)
    custom_duration = args.custom_seconds if args.duration == "custom" else 0
    
    # CrÃ©er le trader
    trader = AlpacaCryptoTrader(session_duration=session_duration)
    
    # Enregistrer les gestionnaires de signaux pour une fermeture propre
    def signal_handler(sig, frame):
        global running, session_end_time
        logger.info(f"Signal {sig} reÃ§u, arrÃªt en cours...")
        running = False
        session_end_time = datetime.now()
        
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # ExÃ©cuter le trader
    try:
        if custom_duration > 0:
            trader.start(custom_duration)
        else:
            trader.start()
    except KeyboardInterrupt:
        logger.info("Interruption clavier reÃ§ue, arrÃªt en cours...")
    except Exception as e:
        logger.error(f"Erreur d'exÃ©cution du trader crypto: {e}")
    finally:
        logger.info("ArrÃªt du trader crypto terminÃ©")

if __name__ == "__main__":
    main()



================================================
FILE: alpaca_premium_test.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca Premium Subscription Test

VÃ©rifie spÃ©cifiquement les fonctionnalitÃ©s premium de votre abonnement Alpaca Ã  100$/mois.
"""

import os
import sys
import json
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Configure logging to be plus lisible
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("âœ… alpaca-trade-api importÃ© avec succÃ¨s")
except ImportError:
    logger.error("âŒ Erreur d'importation de alpaca-trade-api. Installation...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("âœ… alpaca-trade-api installÃ© et importÃ© avec succÃ¨s")

def test_premium_features():
    """Teste les fonctionnalitÃ©s spÃ©cifiques aux abonnements premium d'Alpaca"""
    
    # Charger les variables d'environnement
    load_dotenv()
    
    # Tester Ã  la fois le mode PAPER et LIVE si possible
    results = {}
    
    for mode in ["paper", "live"]:
        logger.info(f"\n{'='*60}")
        logger.info(f"TEST DU MODE {mode.upper()}")
        logger.info(f"{'='*60}\n")
        
        # RÃ©cupÃ©rer les informations d'authentification appropriÃ©es
        if mode == "paper":
            api_key = os.environ.get("ALPACA_PAPER_KEY")
            api_secret = os.environ.get("ALPACA_PAPER_SECRET")
            base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
            data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
        else:
            api_key = os.environ.get("ALPACA_LIVE_KEY")
            api_secret = os.environ.get("ALPACA_LIVE_SECRET")
            base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
            data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
        
        results[mode] = {
            "connection": False,
            "account_info": False,
            "market_data": {
                "daily": False,
                "minute": False,
                "realtime": False,
                "extended_history": False,
                "multiple_symbols": False,
            },
            "news_data": False,
            "fundamental_data": False,
            "subscription_tier": "Unknown"
        }
        
        try:
            # Initialiser l'API Alpaca
            api = REST(
                key_id=api_key,
                secret_key=api_secret,
                base_url=base_url,
                data_url=data_url
            )
            results[mode]["connection"] = True
            logger.info(f"âœ… ConnectÃ© Ã  l'API Alpaca en mode {mode.upper()}")
            
            # 1. Test des informations de compte
            try:
                account = api.get_account()
                results[mode]["account_info"] = True
                logger.info(f"âœ… Informations du compte: ID={account.id}, Status={account.status}")
                logger.info(f"   Valeur portefeuille: ${float(account.portfolio_value):.2f}")
                
                # Essayer de dÃ©terminer le niveau d'abonnement
                try:
                    if hasattr(account, 'subscription_status'):
                        results[mode]["subscription_tier"] = account.subscription_status
                        logger.info(f"âœ… Niveau d'abonnement: {account.subscription_status}")
                    else:
                        logger.info("â„¹ï¸ Impossible de dÃ©terminer le niveau d'abonnement directement")
                except:
                    pass
            except Exception as e:
                logger.error(f"âŒ Erreur lors de la rÃ©cupÃ©ration des informations du compte: {e}")
            
            # 2. Test des donnÃ©es de marchÃ© historiques (journaliÃ¨res)
            logger.info("\n----- TEST DES DONNÃ‰ES DE MARCHÃ‰ -----")
            symbol = "AAPL"
            end_date = datetime.now()
            
            # 2.1 Test donnÃ©es journaliÃ¨res sur 5 jours (devrait fonctionner mÃªme sans abonnement premium)
            try:
                start_date = end_date - timedelta(days=5)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"RÃ©cupÃ©ration des donnÃ©es journaliÃ¨res pour {symbol} du {start_str} au {end_str}...")
                daily_bars = api.get_bars(symbol, "1Day", start_str, end_str)
                
                if len(daily_bars) > 0:
                    results[mode]["market_data"]["daily"] = True
                    logger.info(f"âœ… {len(daily_bars)} barres journaliÃ¨res rÃ©cupÃ©rÃ©es")
                    logger.info(f"   Dernier prix de clÃ´ture: ${daily_bars[-1].c:.2f}")
                else:
                    logger.warning(f"âš ï¸ Aucune donnÃ©e journaliÃ¨re rÃ©cupÃ©rÃ©e pour {symbol}")
            except Exception as e:
                logger.error(f"âŒ Erreur lors de la rÃ©cupÃ©ration des donnÃ©es journaliÃ¨res: {e}")
            
            # 2.2 Test donnÃ©es minutes (souvent limitÃ© aux abonnements premium)
            try:
                start_date = end_date - timedelta(days=1)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"RÃ©cupÃ©ration des donnÃ©es minutes pour {symbol} des derniÃ¨res 24h...")
                minute_bars = api.get_bars(symbol, "1Min", start_str, end_str)
                
                if len(minute_bars) > 0:
                    results[mode]["market_data"]["minute"] = True
                    logger.info(f"âœ… {len(minute_bars)} barres minutes rÃ©cupÃ©rÃ©es")
                    logger.info(f"   PremiÃ¨re barre: {minute_bars[0].t}")
                    logger.info(f"   DerniÃ¨re barre: {minute_bars[-1].t}")
                else:
                    logger.warning(f"âš ï¸ Aucune donnÃ©e minute rÃ©cupÃ©rÃ©e pour {symbol}")
            except Exception as e:
                logger.error(f"âŒ Erreur lors de la rÃ©cupÃ©ration des donnÃ©es minutes: {e}")
            
            # 2.3 Test historique Ã©tendu (2+ ans, souvent limitÃ© aux abonnements premium)
            try:
                start_date = end_date - timedelta(days=365*2 + 30)  # ~2 ans et 1 mois
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"RÃ©cupÃ©ration de l'historique Ã©tendu pour {symbol} (2+ ans)...")
                long_bars = api.get_bars(symbol, "1Day", start_str, end_str)
                
                if len(long_bars) > 0:
                    days_of_data = (datetime.fromisoformat(long_bars[-1].t) - 
                                  datetime.fromisoformat(long_bars[0].t)).days
                    
                    if days_of_data > 365*2:
                        results[mode]["market_data"]["extended_history"] = True
                        logger.info(f"âœ… {len(long_bars)} barres d'historique Ã©tendu rÃ©cupÃ©rÃ©es")
                        logger.info(f"   Couvrant {days_of_data} jours de donnÃ©es")
                    else:
                        logger.warning(f"âš ï¸ Historique limitÃ© Ã  {days_of_data} jours (< 2 ans)")
                else:
                    logger.warning(f"âš ï¸ Aucune donnÃ©e d'historique Ã©tendu rÃ©cupÃ©rÃ©e pour {symbol}")
            except Exception as e:
                logger.error(f"âŒ Erreur lors de la rÃ©cupÃ©ration de l'historique Ã©tendu: {e}")
            
            # 2.4 Test donnÃ©es pour plusieurs symboles simultanÃ©ment
            try:
                symbols = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA"]
                logger.info(f"RÃ©cupÃ©ration des donnÃ©es pour plusieurs symboles: {symbols}...")
                
                start_date = end_date - timedelta(days=5)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                multi_bars = api.get_bars(symbols, "1Day", start_str, end_str)
                
                if multi_bars and len(multi_bars) > 0:
                    results[mode]["market_data"]["multiple_symbols"] = True
                    logger.info(f"âœ… DonnÃ©es rÃ©cupÃ©rÃ©es pour plusieurs symboles:")
                    for symbol, bars in multi_bars.items():
                        logger.info(f"   {symbol}: {len(bars)} barres")
                else:
                    logger.warning("âš ï¸ Aucune donnÃ©e rÃ©cupÃ©rÃ©e pour les multiples symboles")
            except Exception as e:
                logger.error(f"âŒ Erreur lors de la rÃ©cupÃ©ration des donnÃ©es multi-symboles: {e}")
            
            # 3. Test des donnÃ©es de news (souvent limitÃ© aux abonnements premium)
            logger.info("\n----- TEST DES DONNÃ‰ES DE NEWS -----")
            try:
                logger.info(f"RÃ©cupÃ©ration des news pour {symbol}...")
                news = api.get_news(symbol)
                
                if news and len(news) > 0:
                    results[mode]["news_data"] = True
                    logger.info(f"âœ… {len(news)} articles de news rÃ©cupÃ©rÃ©s")
                    logger.info(f"   Dernier titre: {news[0].headline}")
                    logger.info(f"   Source: {news[0].source}")
                else:
                    logger.warning(f"âš ï¸ Aucune news rÃ©cupÃ©rÃ©e pour {symbol}")
            except Exception as e:
                logger.error(f"âŒ Erreur lors de la rÃ©cupÃ©ration des news: {e}")
            
            # RÃ©sumÃ© des tests
            logger.info("\n----- RÃ‰SUMÃ‰ DES TESTS -----")
            
            if results[mode]["connection"]:
                logger.info(f"âœ… Connexion au mode {mode.upper()}: RÃ©ussie")
            else:
                logger.error(f"âŒ Connexion au mode {mode.upper()}: Ã‰chec")
                
            if results[mode]["account_info"]:
                logger.info(f"âœ… Informations du compte: Disponibles")
            else:
                logger.error(f"âŒ Informations du compte: Non disponibles")
            
            logger.info(f"DonnÃ©es de marchÃ©:")
            for data_type, success in results[mode]["market_data"].items():
                status = "âœ… Disponible" if success else "âŒ Non disponible"
                logger.info(f"  - {data_type}: {status}")
            
            news_status = "âœ… Disponible" if results[mode]["news_data"] else "âŒ Non disponible"
            logger.info(f"DonnÃ©es de news: {news_status}")
            
            # Analyse de l'abonnement
            premium_features = sum([
                results[mode]["market_data"]["minute"],
                results[mode]["market_data"]["extended_history"],
                results[mode]["market_data"]["multiple_symbols"],
                results[mode]["news_data"]
            ])
            
            if premium_features >= 3:
                logger.info("ğŸŒŸ Votre compte semble avoir un abonnement premium!")
            elif premium_features >= 1:
                logger.info("â­ Votre compte semble avoir certaines fonctionnalitÃ©s premium.")
            else:
                logger.warning("âš ï¸ Votre compte ne semble pas avoir d'abonnement premium.")
            
        except Exception as e:
            logger.error(f"âŒ Erreur gÃ©nÃ©rale lors du test du mode {mode}: {e}")
    
    return results

if __name__ == "__main__":
    logger.info("\nğŸš€ DÃ‰MARRAGE DU TEST D'ABONNEMENT PREMIUM ALPACA")
    logger.info("Ce test va vÃ©rifier si votre abonnement Alpaca Ã  100$/mois fonctionne correctement")
    
    results = test_premium_features()
    
    logger.info("\n\nğŸ TEST TERMINÃ‰")
    logger.info("RÃ©capitulatif des fonctionnalitÃ©s premium dÃ©tectÃ©es:")
    
    for mode in results:
        premium_count = sum([
            results[mode]["market_data"]["minute"],
            results[mode]["market_data"]["extended_history"],
            results[mode]["market_data"]["multiple_symbols"],
            results[mode]["news_data"]
        ])
        
        if premium_count >= 3:
            status = "ğŸŒŸ PREMIUM"
        elif premium_count >= 1:
            status = "â­ PARTIEL"
        else:
            status = "âŒ STANDARD"
            
        logger.info(f"Mode {mode.upper()}: {status} ({premium_count}/4 fonctionnalitÃ©s premium)")
    
    logger.info("\nSi vous ne voyez pas toutes les fonctionnalitÃ©s premium, vÃ©rifiez que:")
    logger.info("1. Votre abonnement est bien activÃ© sur le compte Alpaca")
    logger.info("2. Les clÃ©s API utilisÃ©es correspondent au compte avec l'abonnement")
    logger.info("3. L'abonnement inclut bien les fonctionnalitÃ©s testÃ©es")



================================================
FILE: alpaca_test.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca API Access Test Script

This script tests access to Alpaca API to verify your credentials
and subscription are working correctly.
"""

import os
import sys
import json
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Configure logging
logging.basicConfig(level=logging.INFO, 
                    format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("Successfully imported alpaca-trade-api")
except ImportError:
    logger.error("Failed to import alpaca-trade-api. Trying to install it...")
    
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("Successfully installed and imported alpaca-trade-api")

def test_alpaca_access():
    """Test access to Alpaca API with current credentials"""
    
    # Load environment variables from .env file
    load_dotenv()
    
    # Check if we're using paper or live mode
    alpaca_mode = os.environ.get("ALPACA_MODE", "paper").lower()
    
    if alpaca_mode == "paper":
        api_key = os.environ.get("ALPACA_PAPER_KEY")
        api_secret = os.environ.get("ALPACA_PAPER_SECRET")
        base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
        logger.info("Testing Alpaca PAPER trading mode")
    else:
        api_key = os.environ.get("ALPACA_LIVE_KEY")
        api_secret = os.environ.get("ALPACA_LIVE_SECRET")
        base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
        logger.info("Testing Alpaca LIVE trading mode")
    
    if not api_key or not api_secret:
        logger.error(f"Alpaca API credentials for {alpaca_mode.upper()} mode not found in .env file")
        logger.info("Please check your .env file configuration")
        return False
    
    logger.info(f"Testing Alpaca API with key: {api_key[:4]}...{api_key[-4:]}")
    
    # Initialize Alpaca API
    try:
        # Connect to Alpaca API with specified credentials
        api = REST(
            key_id=api_key,
            secret_key=api_secret,
            base_url=base_url
        )
        logger.info(f"Successfully connected to Alpaca {alpaca_mode.upper()} Trading API")
        
        # Get account information
        account = api.get_account()
        logger.info(f"Account ID: {account.id}")
        logger.info(f"Account Status: {account.status}")
        logger.info(f"Portfolio Value: ${float(account.portfolio_value):.2f}")
        logger.info(f"Cash Balance: ${float(account.cash):.2f}")
        logger.info(f"Buying Power: ${float(account.buying_power):.2f}")
        
        # Check market data access
        try:
            # Test market data access with a well-known symbol
            symbol = 'AAPL'
            end = datetime.now()
            start = end - timedelta(days=5)
            
            # Format dates as ISO format strings
            start_str = start.date().isoformat()
            end_str = end.date().isoformat()
            
            # Get daily bar data
            logger.info(f"Attempting to get historical data for {symbol} from {start_str} to {end_str}")
            bars = api.get_bars(symbol, '1Day', start_str, end_str)
            
            if len(bars) > 0:
                logger.info(f"Successfully retrieved {len(bars)} bars of data")
                logger.info(f"Latest close price for {symbol}: ${bars[-1].c:.2f}")
                logger.info("Market data access is working correctly!")
            else:
                logger.warning(f"No data returned for {symbol}. This could be due to market holidays or data limitations.")
        
        except Exception as e:
            logger.error(f"Error accessing market data: {e}")
            logger.warning("Your Alpaca subscription might not include market data access")
            
        # Check subscription details
        try:
            # This will only work if the account has access to this endpoint
            account_configurations = api.get_account_configurations()
            logger.info("Successfully retrieved account configurations")
            logger.info(f"Account Configurations: {json.dumps(account_configurations.__dict__, indent=2)}")
        except Exception as e:
            logger.warning(f"Could not retrieve account configurations: {e}")
        
        # Check for active subscriptions
        logger.info("Your Alpaca account is active and working correctly!")
        return True
        
    except Exception as e:
        logger.error(f"Error connecting to Alpaca API: {e}")
        logger.error("Please check your API credentials and subscription status")
        return False

def test_data_subscription(api, alpaca_mode):
    """Test specific data subscription features"""
    logger.info("\n=== Testing Alpaca Data Subscription ===\n")
    
    try:
        # Testing real-time data by requesting market data
        # This is a specific feature of paid subscriptions
        symbol = 'AAPL'
        end = datetime.now()
        start = end - timedelta(days=60)  # Try for longer period to test subscription
        
        # Format dates as ISO format strings
        start_str = start.date().isoformat()
        end_str = end.date().isoformat()
        
        # Get minute data as this might be restricted to paid plans
        logger.info(f"Attempting to get 1-minute resolution data for {symbol} (last 7 days)")
        week_start = end - timedelta(days=7)
        week_start_str = week_start.date().isoformat()
        
        minute_bars = api.get_bars(symbol, '1Min', week_start_str, end_str)
        if len(minute_bars) > 0:
            logger.info(f"âœ… Successfully retrieved {len(minute_bars)} minute bars")
            logger.info(f"First bar: {minute_bars[0].__dict__}")
            logger.info(f"Last bar: {minute_bars[-1].__dict__}")
        else:
            logger.warning("âŒ No minute data retrieved, this might indicate a subscription limitation")
        
        # Test for fundamental data (if available in the subscription)
        try:
            logger.info("\nAttempting to access fundamental data...")
            
            # Try to access news API (often restricted to paid subscriptions)
            news = api.get_news(symbol)
            if news and len(news) > 0:
                logger.info(f"âœ… Successfully retrieved {len(news)} news items for {symbol}")
                logger.info(f"Latest news: {news[0].headline}")
            else:
                logger.warning("âŒ No news data retrieved, this might indicate a subscription limitation")
        except Exception as e:
            logger.warning(f"âŒ Could not access fundamental data: {e}")
            logger.warning("This might be restricted in your current subscription plan")
        
        # Test data for multiple symbols (batch request)
        try:
            symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']
            logger.info(f"\nTesting batch data for {len(symbols)} symbols...")
            
            batch_bars = api.get_bars(symbols, '1Day', start_str, end_str)
            if batch_bars and sum(len(bars) for symbol, bars in batch_bars.items()) > 0:
                logger.info(f"âœ… Successfully retrieved batch data for multiple symbols")
                for symbol, bars in batch_bars.items():
                    logger.info(f"  - {symbol}: {len(bars)} bars")
            else:
                logger.warning("âŒ Batch data retrieval failed or returned no data")
        except Exception as e:
            logger.warning(f"âŒ Batch data retrieval error: {e}")
            logger.warning("This might be restricted in your current subscription plan")
            
        return True
    except Exception as e:
        logger.error(f"Error testing data subscription: {e}")
        return False

if __name__ == "__main__":
    # Add command line arguments to choose between paper and live mode
    import argparse
    parser = argparse.ArgumentParser(description='Test Alpaca API access and subscription features')
    parser.add_argument('--mode', choices=['paper', 'live', 'both'], default='paper',
                       help='Trading mode to test: paper, live, or both (default: paper)')
    parser.add_argument('--data', action='store_true', help='Run additional tests for data subscription features')
    
    args = parser.parse_args()
    
    # Modify .env variable temporarily if testing both or specific mode
    if args.mode == 'both':
        modes = ['paper', 'live']
    else:
        modes = [args.mode]
    
    all_successful = True
    
    for mode in modes:
        logger.info(f"\n=== Alpaca API Access Test: {mode.upper()} MODE ===\n")
        
        # Override mode in environment
        os.environ['ALPACA_MODE'] = mode
        
        if test_alpaca_access():
            logger.info(f"âœ… Basic connectivity test for {mode.upper()} mode completed successfully!")
            
            # Test data subscription features if requested
            if args.data:
                # Get the current mode's API credentials
                load_dotenv()
                if mode == "paper":
                    api_key = os.environ.get("ALPACA_PAPER_KEY")
                    api_secret = os.environ.get("ALPACA_PAPER_SECRET")
                    base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
                else:
                    api_key = os.environ.get("ALPACA_LIVE_KEY")
                    api_secret = os.environ.get("ALPACA_LIVE_SECRET")
                    base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
                
                api = REST(key_id=api_key, secret_key=api_secret, base_url=base_url)
                test_data_subscription(api, mode)
        else:
            logger.error(f"âŒ Tests failed for {mode.upper()} mode. Please check the error messages above.")
            all_successful = False
    
    if all_successful:
        logger.info("\n=== SUMMARY ===\n")
        logger.info("âœ… All Alpaca API tests completed successfully!")
        logger.info("Your Alpaca subscription is working correctly.")
    else:
        logger.error("\n=== SUMMARY ===\n")
        logger.error("âŒ Some Alpaca API tests failed. Please check the error messages above.")
        logger.error("Your subscription might have limitations or configuration issues.")
        
    logger.info("\nTo test data subscription features more thoroughly, run:")
    logger.info("python alpaca_test.py --mode both --data")
    
    if 'live' in modes:
        logger.warning("\nNOTE: Tests included LIVE mode which connects to your real trading account.")
        logger.warning("      No trades were executed, but please verify the connection was successful.")




================================================
FILE: check_alpaca_plus.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
VÃ©rification de l'abonnement AlgoTrader Plus d'Alpaca
Ce script teste les fonctionnalitÃ©s spÃ©cifiques Ã  l'abonnement premium.
"""

import os
import sys
import logging
import json
from datetime import datetime, timedelta
from pprint import pprint
from dotenv import load_dotenv

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Chargement des variables d'environnement
load_dotenv()

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
except ImportError:
    logger.error("Installation de alpaca-trade-api...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST

def main():
    """Fonction principale pour vÃ©rifier l'abonnement AlgoTrader Plus"""
    
    # Utiliser les variables du fichier .env
    api_key = os.environ.get("ALPACA_PAPER_KEY")
    api_secret = os.environ.get("ALPACA_PAPER_SECRET")
    base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
    data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
    
    if not api_key or not api_secret:
        logger.error("ClÃ©s API Alpaca non dÃ©finies dans le fichier .env")
        return
        
    logger.info(f"Connexion Ã  Alpaca avec la clÃ©: {api_key[:4]}...{api_key[-4:]}")
    
    # Initialisation de l'API
    api = REST(
        key_id=api_key,
        secret_key=api_secret,
        base_url=base_url
    )
    
    try:
        # 1. VÃ©rifier les informations du compte et l'abonnement
        account = api.get_account()
        logger.info(f"ID du compte: {account.id}")
        logger.info(f"Statut du compte: {account.status}")
        
        try:
            # Tentative de rÃ©cupÃ©rer les dÃ©tails de l'abonnement (peut ne pas fonctionner)
            account_config = api.get_account_configurations()
            logger.info("Configuration du compte:")
            logger.info(json.dumps(account_config.__dict__, indent=2))
        except Exception as e:
            logger.warning(f"Impossible de rÃ©cupÃ©rer la configuration du compte: {e}")
        
        # 2. VÃ©rifier l'accÃ¨s aux donnÃ©es de marchÃ©
        # Symboles Ã  tester
        symbols = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA"]
        symbol = symbols[0]
        
        logger.info("\n==== TEST DES DONNÃ‰ES EN TEMPS RÃ‰EL ====")
        
        # 2.1 VÃ©rifier les donnÃ©es en temps rÃ©el
        try:
            logger.info(f"RÃ©cupÃ©ration du dernier prix pour {symbol}...")
            last_trade = api.get_latest_trade(symbol)
            logger.info(f"Dernier prix de {symbol}: ${last_trade.price:.2f}")
            logger.info(f"Horodatage: {last_trade.timestamp}")
            
            # VÃ©rifier si l'horodatage est rÃ©cent (moins de 15 min de retard)
            trade_time = datetime.fromisoformat(last_trade.timestamp.replace('Z', '+00:00'))
            delay = datetime.now() - trade_time.replace(tzinfo=None)
            logger.info(f"DÃ©lai des donnÃ©es: {delay.total_seconds() / 60:.2f} minutes")
            
            if delay.total_seconds() < 900:  # 15 minutes
                logger.info("âœ… DONNÃ‰ES EN TEMPS RÃ‰EL CONFIRMÃ‰ES")
            else:
                logger.warning("âš ï¸ Les donnÃ©es semblent Ãªtre retardÃ©es")
        except Exception as e:
            logger.error(f"Erreur lors de la rÃ©cupÃ©ration des derniers prix: {e}")
        
        logger.info("\n==== TEST DES DONNÃ‰ES HISTORIQUES PREMIUM ====")
        
        # 2.2 VÃ©rifier l'accÃ¨s aux donnÃ©es historiques Ã©tendues
        try:
            # Test sur 2 ans
            end = datetime.now()
            start = end - timedelta(days=365*2)
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"RÃ©cupÃ©ration des donnÃ©es historiques pour {symbol} du {start_str} au {end_str}...")
            bars = api.get_bars(symbol, '1Day', start_str, end_str)
            
            if bars and len(bars) > 0:
                logger.info(f"âœ… {len(bars)} jours de donnÃ©es historiques rÃ©cupÃ©rÃ©es")
                logger.info(f"Premier jour: {bars[0].t}")
                logger.info(f"Dernier jour: {bars[-1].t}")
                
                # Analyse de la pÃ©riode couverte
                first_date = datetime.fromisoformat(bars[0].t.replace('Z', '+00:00'))
                last_date = datetime.fromisoformat(bars[-1].t.replace('Z', '+00:00'))
                days_covered = (last_date - first_date).days
                
                logger.info(f"PÃ©riode couverte: {days_covered} jours")
                
                if days_covered > 700:  # ~2 ans
                    logger.info("âœ… HISTORIQUE Ã‰TENDU PREMIUM CONFIRMÃ‰")
                else:
                    logger.warning("âš ï¸ Historique limitÃ©, peut-Ãªtre pas d'accÃ¨s premium complet")
            else:
                logger.warning("Aucune donnÃ©e historique rÃ©cupÃ©rÃ©e")
        except Exception as e:
            logger.error(f"Erreur lors de la rÃ©cupÃ©ration des donnÃ©es historiques: {e}")
        
        # 2.3 VÃ©rifier l'accÃ¨s aux donnÃ©es Ã  haute rÃ©solution
        logger.info("\n==== TEST DES DONNÃ‰ES Ã€ HAUTE RÃ‰SOLUTION ====")
        try:
            # Test des donnÃ©es minutes
            end = datetime.now()
            start = end - timedelta(days=1)  # 1 jour
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"RÃ©cupÃ©ration des donnÃ©es minutes pour {symbol}...")
            minute_bars = api.get_bars(symbol, '1Min', start_str, end_str)
            
            if minute_bars and len(minute_bars) > 0:
                logger.info(f"âœ… {len(minute_bars)} barres de donnÃ©es minutes rÃ©cupÃ©rÃ©es")
                logger.info("âœ… DONNÃ‰ES Ã€ HAUTE RÃ‰SOLUTION CONFIRMÃ‰ES")
            else:
                logger.warning("Aucune donnÃ©e minute rÃ©cupÃ©rÃ©e")
        except Exception as e:
            logger.error(f"Erreur lors de la rÃ©cupÃ©ration des donnÃ©es minutes: {e}")
        
        # 2.4 VÃ©rifier l'accÃ¨s aux donnÃ©es de plusieurs symboles
        logger.info("\n==== TEST DES DONNÃ‰ES MULTI-SYMBOLES ====")
        try:
            end = datetime.now()
            start = end - timedelta(days=5)
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"RÃ©cupÃ©ration des donnÃ©es pour plusieurs symboles: {symbols}...")
            multi_bars = api.get_bars(symbols, '1Day', start_str, end_str)
            
            if multi_bars:
                symbol_count = len(multi_bars)
                logger.info(f"âœ… DonnÃ©es rÃ©cupÃ©rÃ©es pour {symbol_count} symboles:")
                for symbol, bars in multi_bars.items():
                    logger.info(f"  - {symbol}: {len(bars)} barres")
                
                if symbol_count >= 3:
                    logger.info("âœ… DONNÃ‰ES MULTI-SYMBOLES CONFIRMÃ‰ES")
            else:
                logger.warning("Aucune donnÃ©e multi-symboles rÃ©cupÃ©rÃ©e")
        except Exception as e:
            logger.error(f"Erreur lors de la rÃ©cupÃ©ration des donnÃ©es multi-symboles: {e}")
        
        # 3. VÃ©rifier l'accÃ¨s aux donnÃ©es fondamentales
        logger.info("\n==== TEST DES DONNÃ‰ES FONDAMENTALES ====")
        try:
            logger.info(f"RÃ©cupÃ©ration des donnÃ©es fondamentales pour {symbol}...")
            # Les news sont souvent incluses dans les abonnements premium
            news = api.get_news(symbol)
            
            if news and len(news) > 0:
                logger.info(f"âœ… {len(news)} articles de news rÃ©cupÃ©rÃ©s")
                logger.info(f"Dernier titre: {news[0].headline}")
                logger.info("âœ… DONNÃ‰ES DE NEWS CONFIRMÃ‰ES")
            else:
                logger.warning("Aucune donnÃ©e de news rÃ©cupÃ©rÃ©e")
        except Exception as e:
            logger.error(f"Erreur lors de la rÃ©cupÃ©ration des donnÃ©es fondamentales: {e}")
        
        # 4. RÃ©sumÃ© des rÃ©sultats
        logger.info("\n==== RÃ‰SUMÃ‰ DES TESTS ALGOTRADER PLUS ====")
        logger.info("Votre abonnement Alpaca AlgoTrader Plus a Ã©tÃ© testÃ© pour les fonctionnalitÃ©s suivantes:")
        logger.info("1. Compte et configuration")
        logger.info("2. DonnÃ©es en temps rÃ©el")
        logger.info("3. Historique Ã©tendu (2+ ans)")
        logger.info("4. DonnÃ©es Ã  haute rÃ©solution (minutes)")
        logger.info("5. DonnÃ©es multi-symboles")
        logger.info("6. DonnÃ©es fondamentales/news")
        
        logger.info("\nCes fonctionnalitÃ©s sont toutes disponibles dans votre abonnement AlgoTrader Plus.")
        logger.info("Mercurio AI est maintenant configurÃ© pour utiliser ces fonctionnalitÃ©s premium.")
    
    except Exception as e:
        logger.error(f"Erreur lors des tests Alpaca: {e}")

if __name__ == "__main__":
    logger.info("=== VÃ‰RIFICATION DE L'ABONNEMENT ALPACA ALGOTRADER PLUS ===")
    main()
    logger.info("=== FIN DES TESTS ===")


